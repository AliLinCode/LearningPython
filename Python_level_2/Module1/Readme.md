1.0.1 Про курс
Цей курс розроблено та розроблено Інститутом OpenEDG Python у партнерстві з Мережевою академією Cisco .

Курс створений для всіх і кожного , хто хоче вивчити Python і сучасні методи програмування. Це особливо сподобається:


програмісти-початківці та учні, які цікавляться вивченням програмування для розваг і завдань, пов’язаних із роботою;
учні, які хочуть отримати фундаментальні навички та знання для посади початкового рівня розробника програмного забезпечення, аналітика даних або тестувальника;
професіонали галузі , які бажають досліджувати технології, пов’язані з Python, або які використовують його як основу;
керівники команд, менеджери продуктів і менеджери проектів, які хочуть зрозуміти термінологію та процеси в циклі розробки програмного забезпечення, щоб ефективніше керувати та спілкуватися з командами виробництва та розробки.
Під час курсу ви матимете доступ до практичних практичних матеріалів, лабораторних робіт, тестів, оцінювань і тестів, щоб навчитися використовувати навички та знання, отримані під час вивчення ресурсів і виконання завдань програмування, а також взаємодіяти з деякими реальними проблемами програмування і ситуації.
1.0.2 Програма
У цьому курсі ви дізнаєтеся:

як застосувати загальні методи кодування та найкращі практики у своїх проектах;
як обробляти рядки;
як використовувати об’єктно-орієнтоване програмування на Python;
як імпортувати та використовувати модулі Python, зокрема модулі math , random , platform , os , time , datetime та calendar ;
як створювати та використовувати власні модулі та пакети Python;
як використовувати механізм винятків у Python;
як використовувати генератори, ітератори та закриття в Python;
як обробляти файли.
Курс розділений на чотири модулі:

Модуль 1
Модулі, пакети та PIP;
Модуль 2
Рядки, рядкові та спискові методи та винятки;
Модуль 3
Об'єктно-орієнтоване програмування;
Модуль 4
Різне (генератори, ітератори, закриття, файлові потоки, обробка текстових і бінарних файлів, ОС, час, дата, час і модуль календаря).

1.0.3 Підготуйтеся до іспиту PCAP-31-0x
Пориньте в програмування, вивчіть Python з нуля та підготуйтеся до сертифікації PCAP – Certified Associate in Python Programming
Python Essentials 2 узгоджується з сертифікатом PCAP – Certified Associate in Python Programming , професійним сертифікатом, який демонструє розуміння власником синтаксису та семантики мови Python, а також його вміння використовувати найважливіші елементи мови, інструменти та ресурси для проектування, розробки та рефакторингу простих програм Python.

Сертифікація дає вам змогу підтримувати свої навички в актуальному стані та демонструвати їх іншим. Це дає вам можливість перевірити, підтвердити та підтвердити свої здібності програмування на Python. Найважливіше те, що це може відкрити двері до кращої роботи та кращої зарплати, а також є чудовим мотиватором для самовдосконалення та саморозвитку.


Сертифікація PCAP – Certified Associate in Python Programming є проміжним кроком до сертифікації PCPP1 – Certified Professional in Python Programming 1 і відправною точкою для початку кар’єри в розробці програмного забезпечення, програмуванні на Python і пов’язаних технологіях.

Сертифікація PCAP допоможе вам виділитися з-поміж інших кандидатів і потрапити у двері , а після завершення цього курсу ви матимете право на 50% знижку на сертифікаційний іспит !

Для отримання додаткової інформації про сертифікацію PCAP – Certified Associate in Python Programming відвідайте www.pythoninstitute.org .

Отже, ви готові почати свою подорож Python? Натисніть «Далі» , щоб перейти до розділу 1 і почати навчання. Побачимось там!


1.1.1 Що таке модуль?
Комп'ютерний код має тенденцію до зростання. Ми можемо сказати, що код, який не росте, ймовірно, повністю непридатний для використання або покинутий. Справжній, потрібний і широко використовуваний код постійно розвивається, оскільки вимоги та очікування користувачів розвиваються у власному ритмі.

Код, який не відповідає потребам користувачів, буде швидко забутий і миттєво замінений новим, кращим і більш гнучким кодом. Будьте готові до цього і ніколи не думайте, що будь-яка з ваших програм зрештою буде завершена. Завершення є перехідним станом і зазвичай проходить швидко, після першого повідомлення про помилку. Сам Python є хорошим прикладом того, як діє правило.

Зростаючий код насправді є зростаючою проблемою. Більший код завжди означає складніше обслуговування. Шукати помилки завжди легше там, де код менший (подібно до того, як знайти механічну поломку легше, коли механізм простіший і менший).

Крім того, коли очікується, що створюваний код буде дійсно великим (ви можете використовувати загальну кількість вихідних рядків як корисну, але не дуже точну міру розміру коду), ви можете захотіти (точніше, ви будете змушені) розділити його на багато частин, реалізованих паралельно кількома, десятками, кількома десятками або навіть кількома сотнями окремих розробників.

Звичайно, це неможливо зробити за допомогою одного великого вихідного файлу, який редагується всіма програмістами одночасно. Це неодмінно призведе до вражаючої катастрофи.

Якщо ви хочете, щоб такий програмний проект був успішно завершений, ви повинні мати засоби, які дозволять вам:

розподілити всі завдання між розробниками;
з'єднати всі створені частини в одне робоче ціле.
Наприклад, певний проект можна розділити на дві основні частини:

інтерфейс користувача (частина, яка спілкується з користувачем за допомогою віджетів і графічного екрана)
логіка (частина, яка обробляє дані та створює результати)
Кожну з цих частин можна (швидше за все) розділити на менші і так далі. Такий процес часто називають декомпозицією .

Наприклад, якби вас попросили організувати весілля, ви б не зробили все самі – ви б знайшли кілька професіоналів і розділили завдання між ними.

Як розділити частину програмного забезпечення на окремі, але взаємодіючі частини? Ось у чому питання. Модулі - це відповідь.

1.1.2 Як використовувати модуль?
Отже, що таке модуль? Підручник з Python визначає його як файл, що містить визначення та оператори Python , які пізніше можна імпортувати та використовувати за потреби.

Обробка модулів складається з двох різних питань:

перший (мабуть, найпоширеніший) трапляється, коли ви хочете використати вже існуючий модуль, написаний кимось іншим або створений вами під час вашої роботи над якимось складним проектом - у цьому випадку ви є користувачем модуля ;
другий виникає, коли ви хочете створити абсолютно новий модуль або для власного використання, або для полегшення життя інших програмістів - ви є постачальником модуля .
Давайте обговоримо їх окремо.

Перш за все, модуль ідентифікується за його назвою . Якщо ви хочете використовувати будь-який модуль, вам потрібно знати назву. Разом із самим Python поставляється (досить велика) кількість модулів. Ви можете думати про них як про "додаткове обладнання Python".

Усі ці модулі разом із вбудованими функціями утворюють стандартну бібліотеку Python — особливий вид бібліотеки, де модулі виконують роль книг (можна навіть сказати, що папки виконують роль полиць). Якщо ви хочете переглянути повний список усіх «томів», зібраних у цій бібліотеці, ви можете знайти його тут: https://docs.python.org/3/library/index.html .

Кожен модуль складається з сутностей (як книга складається з розділів). Ці сутності можуть бути функціями, змінними, константами, класами та об’єктами. Якщо ви знаєте, як отримати доступ до певного модуля, ви можете використовувати будь-які сутності, які він зберігає.


1.1.3 Імпортування модуля
Щоб зробити модуль придатним для використання, ви повинні його імпортувати (подумайте про це як про те, щоб взяти книгу з полиці). Імпортування модуля виконується інструкцією під назвоюімпорт. Примітка:імпорттакож є ключовим словом (з усіма наслідками цього факту).

Припустімо, що ви хочете використовувати дві сутності, надані вматематикамодуль:

символ (константа), що представляє точне (якомога точніше, використовуючи подвійну арифметику з плаваючою комою) значення π (хоча використання грецької літери для назви змінної цілком можливо в Python, символ називається pi - це зручніше рішення , особливо для тієї частини світу, яка не має та не збирається використовувати грецьку клавіатуру)
функція з назвоюгріх()(комп’ютерний еквівалент математичної функції синус )

Обидві ці сутності доступні черезматематикамодуль, але спосіб, у який ви можете використовувати їх, сильно залежить від того, як було виконано імпорт.

Найпростіший спосіб імпортувати окремий модуль — це використати наступну інструкцію імпорту:


import math
 
Пункт містить:

вімпортключове слово;
назва модуля , який підлягає імпорту.
Інструкцію можна розташувати будь-де у вашому коді, але її потрібно розмістити перед першим використанням будь-якої сутності модуля .

Якщо ви хочете (або повинні) імпортувати більше одного модуля, ви можете зробити це, повторившиімпортпункт (бажано):


import math
import sys
або перерахувавши модулі післяімпортключове слово, як тут:


import math, sys
Інструкція імпортує два модулі, перший з яких називаєтьсяматематикаа потім другий імсистема.

Список модулів може бути як завгодно довгим.

1.1.4 Простір імен
Щоб продовжити, вам потрібно ознайомитися з важливим терміном: простір імен . Не хвилюйтеся, ми не будемо вдаватися в подробиці - це пояснення буде максимально коротким.

Простір імен — це простір (розуміється в нефізичному контексті), у якому існують деякі імена, які не конфліктують між собою (тобто немає двох різних об’єктів з однаковою назвою). Ми можемо сказати, що кожна соціальна група є простором імен - група прагне називати кожного свого члена унікальним способом (наприклад, батьки не дадуть своїм дітям однакові імена).


Цієї унікальності можна досягти багатьма способами, наприклад, використовуючи псевдоніми разом з іменами (це буде працювати всередині невеликої групи, як клас у школі) або шляхом призначення спеціальних ідентифікаторів усім членам групи (Соціальне забезпечення США Хорошим прикладом такої практики є Number).

У певному просторі імен кожне ім’я має залишатися унікальним . Це може означати, що деякі імена можуть зникнути, коли будь-яка інша сутність із уже відомою назвою входить у простір імен. Ми покажемо вам, як це працює та як ним керувати, але спочатку повернемося до імпорту.

Якщо модуль із вказаною назвою існує та є доступним (модуль насправді є вихідним файлом Python ), Python імпортує його вміст, тобто всі імена, визначені в модулі, стають відомими , але вони не входять у простір імен вашого коду.

Це означає, що ви можете мати власні назви сутностейгріхабопіі імпорт жодним чином не вплине на них.


На цьому етапі вам може бути цікаво, як отримати доступ допіщо походить відматематикамодуль.

Щоб зробити це, ви повинні пройти кваліфікаціюпіз назвою вихідного модуля.
![img.png](img.png)
1.1.5 Імпортування модуля: продовження
Цей перший приклад не буде дуже складним – ми просто хочемо надрукувати значення sin(½π) .

Подивіться на код у редакторі. Ось як ми це перевіряємо.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Код виводить очікуване значення:1.0.

Подивіться на фрагмент нижче, це спосіб, у який ви кваліфікуєте іменапіігріхз назвою вихідного модуля:


math.pi
math.sin
Це просто, ви ставите:

назву модуля (наприклад,математика)
крапка ( тобто.)
назву організації (наприклад,пі)
Така форма чітко вказує простір імен, у якому існує назва.

Примітка: використання цієї кваліфікації є обов’язковим , якщо модуль було імпортованоімпортмодульна інструкція. Немає значення, конфліктують чи ні будь-які імена з вашого коду та з простору імен модуля.

Примітка: видалення будь-якої з двох кваліфікацій зробить код помилковим. Немає іншого способу ввести простір імен math, якщо ви зробили наступне:


import math
Тепер ми покажемо вам, як можуть співіснувати два простори імен (ваш і модульного).

Подивіться на приклад у вікні редактора.

Ми визначили наші власні пі ігріхтут.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Запустіть програму. Код має вивести наступний результат:

0.99999999
1.0
Вихід
Як бачите, сутності не впливають одна на одну.

У другому способіімпортСинтаксис точно вказує, яка сутність модуля (або сутності) прийнятна в коді:


from math import pi
Інструкція складається з наступних елементів:

ввідключове слово;
ім'я модуля, який (вибірково) імпортується;
вімпортключове слово;
ім'я або список імен сутності/сутностей , які імпортуються в простір імен.
Інструкція має такий ефект:

перераховані сутності (і тільки ті) імпортуються з указаного модуля ;
назви імпортованих об'єктів доступні без застережень .
Примітка: інші сутності не імпортуються. Більше того, ви не можете імпортувати додаткові сутності за допомогою кваліфікації — такого рядка:


print(math.e)
викличе помилку (дце число Ейлера: 2,71828...)

Давайте перепишемо попередній сценарій, щоб включити нову техніку.

Ось:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Результат має бути таким самим, як і раніше, оскільки фактично ми використовували ті самі сутності, що й раніше:1.0. Скопіюйте код, вставте його в редактор і запустіть програму.

Код виглядає простішим? Можливо, але зовнішній вигляд – не єдиний ефект такого імпорту. Давайте покажемо вам це.

Подивіться на код у редакторі. Уважно проаналізуйте:

рядок 1: здійснити вибірковий імпорт;
рядок 3: скористайтеся імпортованими сутностями та отримайте очікуваний результат (1.0)
рядки з 5 по 12: перевизначте значенняпіігріх- по суті, вони замінюють оригінальні (імпортовані) визначення в просторі імен коду;
рядок 15: отримати0,99999999, що підтверджує наші висновки.
play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Зробимо ще один тест. Подивіться на код нижче:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Тут ми змінили послідовність операцій коду на протилежну:

рядки з 1 по 8: визначимо наші власніпіігріх;
рядок 11: використовуйте їх (0,99999999з’являється на екрані)
рядок 13: виконати імпорт — імпортовані символи замінюють свої попередні визначення в просторі імен ;
рядок 15: отримати1.0в результаті.
1.1.6 Імпортування модуля: *
У третьому способіімпортсинтаксис є більш агресивною формою представленого раніше:


from module import *
 
Як ви бачите, ім'я сутності (або список імен сутностей) замінюється однією зірочкою (*).

Така інструкція імпортує всі сутності з указаного модуля .

Це зручно? Так, це звільняє вас від обов’язку перераховувати всі потрібні імена.

Це небезпечно? Так, це так - якщо ви не знаєте всіх назв, наданих модулем, ви не зможете уникнути конфліктів імен . Розглядайте це як тимчасове рішення та намагайтеся не використовувати його в звичайному коді.
1.1.7 Ключове слово as
Якщо ви використовуєте варіант модуля імпорту і вам не подобається ім’я певного модуля (наприклад, воно збігається з однією з ваших уже визначених сутностей, тому кваліфікація стає складною), ви можете дати йому будь-яке ім’я, яке вам подобається – це називається псевдонімом .

Псевдоніми призводять до того, що модуль ідентифікується під назвою, відмінною від оригінальної. Це також може скоротити кваліфіковані імена.

Створення псевдоніма виконується разом з імпортом модуля та вимагає такої форми інструкції імпорту:


import module as alias
 
«Модуль» визначає ім’я вихідного модуля, а «псевдонім» — це ім’я, яке ви бажаєте використовувати замість оригіналу.

Примітка:якє ключовим словом.
1.1.8 Псевдоніми
Якщо потрібно змінити словоматематика, ви можете ввести власне ім’я, як у прикладі:


import math as m
    
print(m.sin(m.pi/2))
 
Примітка: після успішного виконання псевдонімного імпорту оригінальне ім’я модуля стає недоступним і його не можна використовувати.

У свою чергу, коли ви використовуєтез імені імпорту модуляваріант, і вам потрібно змінити назву сутності, ви створюєте псевдонім для сутності. Це призведе до того, що ім’я буде замінено вибраним вами псевдонімом.

Ось як це можна зробити:


from module import name as alias
 
Як і раніше, вихідне (без псевдонімів) ім’я стає недоступним.

Фразаім'я як псевдонімможна повторювати - використовуйте коми, щоб розділити помножені фрази, наприклад:


from module import n as a, m as b, o as c
  
Приклад може виглядати трохи дивно, але він працює:


from math import pi as PI, sin as sine
  
print(sine(PI/2))
  
Тепер ви знайомі з основами використання модулів. Давайте покажемо вам деякі модулі та деякі їхні корисні сутності.

1.1.9 РЕЗЮМЕ РОЗДІЛУ
1. Якщо ви хочете імпортувати модуль як ціле, ви можете зробити це за допомогоюІмпорт модуля_назвазаява. Ви можете імпортувати більше одного модуля одночасно, використовуючи список, розділений комами. Наприклад:


import mod1
import mod2, mod3, mod4
   
хоча остання форма не рекомендована через стилістичні міркування, і краще й красивіше виражати той самий намір у більш багатослівній та явній формі, наприклад:


import mod2
import mod3
import mod4
  
2. Якщо модуль імпортовано вищевказаним способом і ви бажаєте отримати доступ до будь-якої з його сутностей, вам потрібно додати префікс до назви сутності за допомогою крапкової нотації. Наприклад:


import my_module
   
result = my_module.my_function(my_module.my_data)
 
Фрагмент використовує дві сутності, що надходять ізмій_модульмодуль: функція з іменеммоя_функція()і змінна з іменеммої_дані. Обидві назви повинні мати префікс мій_модуль. Жодне з імпортованих імен об’єктів не конфліктує з ідентичними іменами, наявними в просторі імен вашого коду.

3. Ви можете імпортувати не тільки модуль в цілому, але й окремі його сутності. У цьому випадку імпортовані сутності не повинні мати префікс під час використання. Наприклад:


from module import my_function, my_data
  
result = my_function(my_data)
 
Наведений вище спосіб, незважаючи на його привабливість, не рекомендується через небезпеку виникнення конфліктів з іменами, отриманими в результаті імпорту простору імен коду.

4. Найзагальніша форма наведеного вище оператора дозволяє імпортувати всі сутності , запропоновані модулем:


from my_module import *
  
result = my_function(my_data)
 
Примітка: цей варіант імпорту не рекомендований через ті ж причини, що й попередні (тут загроза конфлікту імен ще небезпечніша).

5. Ви можете змінити назву імпортованої сутності «на льоту», використовуючиякфраза вімпорт. Наприклад:


from module import my_function as fun, my_data as dat
  
result = fun(dat)


1.2.1 Робота зі стандартними модулями
Перш ніж ми почнемо розглядати деякі стандартні модулі Python, ми хочемо представитиdir()функція для вас. Це не має нічого спільного зрежкоманда, яку ви знаєте з консолей Windows і Unix, якdir()не показує вміст каталогу/папки на диску, але не можна заперечувати, що він робить щось подібне – він здатний розкривати всі імена, надані через певний модуль.

Є одна умова: модуль має бути попередньо імпортований цілком (тобто за допомогоюмодуль імпортуінструкція -з модулянедостатньо).

Функція повертає впорядкований за алфавітом список, що містить усі імена об’єктів, доступні в модулі, визначені іменем, переданим функції як аргумент:


dir(module)
  
Примітка: якщо назву модуля було псевдонімом, ви повинні використовувати псевдонім, а не оригінальну назву.

Використання функції у звичайному сценарії не має особливого сенсу, але все ж можливо.

Наприклад, ви можете запустити такий код, щоб надрукувати імена всіх сутностей у математичному модулі:


import math
  
for name in dir(math):
  print(name, end="∖t")
Приклад коду має вивести наступний результат:

__doc__ __loader__ __name__ __package__ __spec__ acos acosh asin asinh atan atan2
atan2 atanh ceil copysign cos cosh degrees e erf erfc exp expm1 fabs factorial floor
fmod frexp fsum gamma hypot isfinite isinf isnan ldexp lgamma log log10 log1p
log2 modf pi pow radians sin sinh sqrt tan tanh trunc
Вихід
Ви помітили ці дивні імена, що починаються з__у верхній частині списку? Ми розповімо вам більше про них, коли будемо говорити про проблеми, пов’язані з написанням власних модулів.

Деякі назви можуть викликати спогади з уроків математики, і, ймовірно, у вас не виникне проблем з здогадуванням їх значення.

Використовуючиdir()Функція всередині коду може здатися не дуже корисною - зазвичай ви хочете знати вміст конкретного модуля, перш ніж писати та запускати код.

На щастя, ви можете виконати функцію безпосередньо в консолі Python (IDLE), без необхідності писати та запускати окремий сценарій.

Ось як це можна зробити:


import math
dir(math)
Ви повинні побачити щось подібне до цього:


![img_1.png](img_1.png)

 1.2.2 Вибрані функції з математичного модуля
Почнемо з короткого попереднього перегляду деяких функцій, які надаєматематикамодуль.

Ми вибрали їх довільно, але це не означає, що функції, про які ми тут не згадали, менш важливі. Пориньте в глибини модулів самостійно - у нас немає ні місця, ні часу, щоб говорити про все докладно тут.

Перша група вматематикафункції пов'язані з тригонометрією :

sin(x)→ синус x;
cos(x)→ косинус x;
загар(x)→ тангенс x.
Усі ці функції приймають один аргумент (вимірювання кута, виражене в радіанах) і повертають відповідний результат (будьте обережні ззагар()- не всі аргументи приймаються).

Звичайно, існують і їх зворотні версії:

asin(x)→ арксинусу x;
acos(x)→ аркосинус x;
atan(x)→ арктангенс x.
Ці функції приймають один аргумент (зверніть увагу на домени) і повертають міру кута в радіанах.

Щоб ефективно виконувати вимірювання кутів,математикамодуль надає вам такі сутності:

пі→ константа зі значенням, яке є наближенням π;
радіани (x)→ функція, яка перетворює x із градусів у радіани;
градуси (x)→ діючи в іншому напрямку (від радіан до градусів)
Тепер подивіться на код у редакторі. Приклад програми не дуже складний, але чи можете ви передбачити її результати?

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Крім циклічних функцій (перелічених вище),математикамодуль також містить набір їх гіперболічних аналогів :

sinh(x)→ гіперболічний синус;
cosh(x)→ гіперболічний косинус;
tanh(x)→ гіперболічний тангенс;
asinh(x)→ гіперболічний арксинус;
acosh(x)→ гіперболічний арккосинус;
atanh(x)→ гіперболічний арктангенс.
Інша група зматематикафункції утворюють функції, які пов'язані з піднесенням до степеня :

д→ константа зі значенням, яке є наближенням числа Ейлера (e)
exp(x)→ знаходження значення e x ;
log(x)→ натуральний логарифм x
log(x, b)→ логарифм x за основою b
log10(x)→ десятковий логарифм x (точніше ніжlog(x, 10))
log2(x)→ двійковий логарифм x (точніше ніжlog(x, 2))
Примітка:pow()функція:

pow(x, y)→ знаходження значення x y (зверніть увагу на домени)
Це вбудована функція, яку не потрібно імпортувати.

Подивіться на код у редакторі. Чи можете ви передбачити його вихід?

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Остання група складається з деяких функцій загального призначення, наприклад:

стеля (x)→ стеля x (найменше ціле число, більше або рівне x)
поверх (x)→ підлога x (найбільше ціле число, менше або дорівнює x)
trunc(x)→ значення x скорочено до цілого числа (будьте обережні - це не еквівалент ceil чи floor)
факториал(x)→ повертає x! (x має бути інтегралом, а не від’ємним)
гіпот(х, у)→ повертає довжину гіпотенузи прямокутного трикутника з довжинами катетів, що дорівнюють x і y (те саме, щоsqrt(pow(x, 2) + pow(y, 2))але точніше)
Подивіться на код у редакторі. Уважно проаналізуйте програму.

Він демонструє принципові відмінності міжстеля(),поверх()іtrunc().

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Запустіть програму та перевірте її вихід.


1.2.3 Чи існує справжня випадковість у комп’ютерах?
Ще один модуль, який варто згадати, це названийвипадковий.

Він надає деякі механізми, що дозволяють вам працювати з псевдовипадковими числами .

Зверніть увагу на префікс псевдо — числа, згенеровані модулями, можуть виглядати випадковими в тому сенсі, що ви не можете передбачити їхні подальші значення, але не забувайте, що всі вони обчислюються за допомогою дуже вдосконалених алгоритмів.

Алгоритми не є випадковими – вони детерміновані та передбачувані. Лише ті фізичні процеси, які повністю виходять з-під нашого контролю (наприклад, інтенсивність космічного випромінювання), можуть бути використані як джерело фактичних випадкових даних. Дані, створені детермінованими комп’ютерами, жодним чином не можуть бути випадковими.

Генератор випадкових чисел приймає значення, яке називається початковим значенням , розглядає його як вхідне значення, обчислює на його основі «випадкове» число (метод залежить від вибраного алгоритму) і створює нове початкове значення .

Тривалість циклу, в якому всі вихідні значення унікальні, може бути дуже довгою, але вона не нескінченна – рано чи пізно вихідні значення почнуть повторюватися, і генеруючі значення також повторюватимуться. Це нормально. Це функція, а не помилка чи баг.

Початкове початкове значення, встановлене під час запуску програми, визначає порядок, у якому відображатимуться згенеровані значення.


Фактор випадковості процесу можна збільшити, встановивши початкове число з числом, узятим із поточного часу - це може гарантувати, що кожен запуск програми починатиметься з іншого початкового значення (отже, використовуватимуться різні випадкові числа).

На щастя, така ініціалізація виконується Python під час імпорту модуля.

1.2.4 Вибрані функції з випадкового модуля
Theвипадковийфункція
Найзагальніша функція назвипадковий()(не плутати з назвою модуля) створює число з плаваючою речовиноюxщо надходить з діапазону (0,0, 1,0)- іншими словами: (0,0 <= x < 1,0).

Наведений нижче приклад програми створить п’ять псевдовипадкових значень – оскільки їхні значення визначаються поточним (досить непередбачуваним) початковим значенням, ви не можете їх вгадати:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Запустіть програму. Ось що ми маємо:

0.9535768927411208
0.5312710096244534
0.8737691983477731
0.5896799172452125
0.02116716297022092
Вихід
Theнасінняфункція
Theнасіння()функція здатна безпосередньо встановлювати початкове значення генератора . Ми покажемо вам два його варіанти:

насіння()- встановлює зерно з поточним часом;
насіння (ціле_значення)- встановлює зерно з цілим значенням int_value.
Ми змінили попередню програму – по суті, ми видалили будь-які сліди випадковості з коду:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Через те, що початкове значення завжди встановлюється з однаковим значенням, послідовність згенерованих значень завжди виглядає однаково.

Запустіть програму. Ось що ми маємо:

0.844421851525
0.75795440294
0.420571580831
0.258916750293
0.511274721369
Вихід
І ти?

Примітка: ваші значення можуть дещо відрізнятися від наших, якщо ваша система використовує точнішу або менш точну арифметику з плаваючою комою, але різницю буде помітно далеко від десяткової коми.

Theранддіапазонірандітфункції
Якщо вам потрібні цілі випадкові значення, краще підійде одна з наступних функцій:

діапазон (кінець)
randrange(початок, кінець)
randrange(початок, кінець, крок)
randint (ліворуч, праворуч)
Перші три виклики згенерують ціле число, взяте (псевдовипадково) з діапазону (відповідно):

діапазон (кінець)
діапазон (початок, кінець)
діапазон (початок, кінець, крок)
Зверніть увагу на неявне правостороннє виключення !

Остання функція є еквівалентомранддіапазон (ліворуч, праворуч+1)- генерує ціле значенняi, який потрапляє в діапазон [ліворуч, праворуч] (без виключення з правого боку).

Подивіться на код у редакторі. Цей зразок програми, як наслідок, виведе рядок, що складається з трьох нулів і нуля або одиниці на четвертому місці.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Попередні функції мають один важливий недолік - вони можуть створювати повторювані значення, навіть якщо кількість наступних викликів не перевищує ширину зазначеного діапазону.

Подивіться на наведений нижче код - програма, швидше за все, виведе набір чисел, деякі елементи в якому не є унікальними:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Ось що ми отримали в одному із запусків:

9,4,5,4,5,8,9,4,8,4,
Вихід
Theвибірізразокфункції
Як бачите, це не дуже хороший інструмент для генерування чисел у лотерею. На щастя, є кращий вихід, ніж написання власного коду для перевірки унікальності «намальованих» чисел.

Це функція, названа дуже навіювано -вибір:

вибір (послідовність)
зразок(послідовність, елементи_на_вибір)
Перший варіант вибирає «випадковий» елемент із вхідної послідовності та повертає його.

Другий створює список (вибірку), що складається зелементи_на_вибірелемент, "витягнутий" із вхідної послідовності.

Іншими словами, функція вибирає деякі з вхідних елементів, повертаючи список із вибором. Елементи у вибірці розміщуються у довільному порядку. Примітка:елементи_на_вибірне має перевищувати довжину вхідної послідовності.

Подивіться на код нижче:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Знову ж таки, результати програми непередбачувані. Наші результати виглядали так:

4
[3, 1, 8, 9, 10]
[10, 8, 5, 1, 6, 4, 3, 9, 7, 2]


1.2.5 Як дізнатися, де ви знаходитесь?
Іноді може знадобитися дізнатися інформацію, не пов’язану з Python. Наприклад, вам може знадобитися розташування вашої програми в загальному середовищі комп’ютера.

Уявіть середовище вашої програми як піраміду, що складається з кількох рівнів або платформ.

Шари:
![img_2.png](img_2.png)

ваш (запущений) код розташований у верхній частині;
Python (точніше - його середовище виконання) лежить безпосередньо під ним;
наступний рівень піраміди заповнює ОС (операційна система) – середовище Python надає деякі свої функції за допомогою служб операційної системи; Хоча Python дуже потужний, він не всемогутній — він змушений використовувати багато помічників, якщо він збирається обробляти файли або спілкуватися з фізичними пристроями;
самий нижній рівень — апаратне забезпечення — процесор (або процесори), мережеві інтерфейси, пристрої людського інтерфейсу (миші, клавіатури тощо) та всі інші механізми, необхідні для роботи комп’ютера; ОС знає, як керувати цим, і використовує багато хитрощів, щоб вести всі частини в узгодженому ритмі.

Це означає, що деякі ваші дії (точніше вашої програми) повинні пройти довгий шлях, щоб бути успішно виконаними - уявіть, що:

Ваш код хоче створити файл, тому він викликає одну з функцій Python;
Python приймає порядок, змінює його відповідно до вимог локальної ОС (це як поставити штамп «схвалено» на вашому запиті) і надсилає його вниз (це може нагадувати вам ланцюжок команд)
ОС перевіряє , чи запит обґрунтований і дійсний (наприклад, чи відповідає ім'я файлу деяким правилам синтаксису) і намагається створити файл; така операція, яка здається дуже простою, не є атомарною - вона складається з багатьох незначних кроків, які виконує...
Апаратне забезпечення , яке відповідає за активацію пристроїв зберігання (жорсткий диск, твердотільні пристрої тощо) для задоволення потреб ОС.
Зазвичай ви не усвідомлюєте всієї цієї метушні – ви хочете, щоб файл був створений, і все.

Але іноді ви хочете знати більше, наприклад, назву ОС, на якій розміщено Python, і деякі характеристики, що описують апаратне забезпечення, на якому розміщено ОС.

Є модуль, який надає певні засоби, які дозволяють вам знати, де ви знаходитесь і які компоненти вам підходять. Модуль називається платформа . Ми покажемо вам деякі функції, які він вам надає.

1.2.6 Вибрані функції з модуля платформи
Theплатформафункція
TheплатформаМодуль дозволяє отримати доступ до даних базової платформи, тобто до інформації про обладнання, операційну систему та версію інтерпретатора.

Існує функція, яка може відразу показати всі нижчі шари з назвоюплатформатеж. Він просто повертає рядок, що описує середовище; таким чином, його результат адресований радше людям, ніж автоматизованій обробці (незабаром ви це побачите).

Ось як ви можете викликати його:


platform(aliased = False, terse = False)
 
І зараз:

псевдонім→ коли встановленоПравда(або будь-яке ненульове значення) це може призвести до того, що функція представить альтернативні назви нижнього шару замість звичайних;
лаконічний→ коли встановленоПравда(або будь-яке ненульове значення) це може переконати функцію представити більш стислу форму результату (якщо можливо)
Ми запустили нашу прикладну програму:


from platform import platform
 
print(platform())
print(platform(1))
print(platform(0, 1))
 
використовуючи три різні платформи - ось що ми отримали:

Intel x86 + Windows ® Vista (32 біт):
Windows-Vista-6.0.6002-SP2
Windows-Vista-6.0.6002-SP2
Windows-Vista
Вихід
Intel x86 + Gentoo Linux (64 біт):
Linux-3.18.62-g6-x86_64-Intel-R-_Core-TM-_i3-2330M_CPU_@_2.20GHz-with-gentoo-2.3
Linux-3.18.62-g6-x86_64-Intel-R-_Core-TM-_i3-2330M_CPU_@_2.20GHz-with-gentoo-2.3
Linux-3.18.62-g6-x86_64-Intel-R-_Core-TM-_i3-2330M_CPU_@_2.20GHz-with-glibc2.3.4
Вихід
Raspberry PI2 + Raspbian Linux (32 біт)
Linux-4.4.0-1-rpi2-armv7l-with-debian-9.0
Linux-4.4.0-1-rpi2-armv7l-with-debian-9.0
Linux-4.4.0-1-rpi2-armv7l-with-glibc2.9
Вихід
Ви також можете запустити зразок програми в IDLE на вашій локальній машині, щоб перевірити, який результат ви отримаєте.

Theмашинафункція
Іноді ви можете просто захотіти знати загальну назву процесора, який запускає вашу ОС разом із Python і ваш код - функція під назвоюмашина()скажу вам це. Як і раніше, функція повертає рядок.

Знову ми запустили приклад програми:


from platform import machine
 
print(machine())
на трьох різних платформах:

Intel x86 + Windows ® Vista (32 біт):
x86
Вихід
Intel x86 + Gentoo Linux (64 біт):
x86_64
Вихід
Raspberry PI2 + Raspbian Linux (32 біт):
armv7l
Вихід
Theпроцесорфункція
Theпроцесор()функція повертає рядок, заповнений справжньою назвою процесора (якщо можливо).

Ще раз ми запустили приклад програми:


from platform import processor
 
print(processor())
на трьох різних платформах:

Intel x86 + Windows ® Vista (32 біт):
x86
Вихід
Intel x86 + Gentoo Linux (64 біт):
Intel(R) Core(TM) i3-2330M CPU @ 2.20GHz
Вихід
Raspberry PI2 + Raspbian Linux (32 біт):
armv7l
Вихід
Перевірте це на своїй локальній машині.

Theсистемафункція
Функція з назвоюсистема()повертає загальну назву ОС у вигляді рядка.


from platform import system
 
print(system())
 
Наші приклади платформ представили себе так:

Intel x86 + Windows ® Vista (32 біт):
Windows
Вихід
Intel x86 + Gentoo Linux (64 біт):
Linux
Вихід
Raspberry PI2 + Raspbian Linux (32 біт):
Linux
Вихід
Theверсіяфункція
Версія ОС надається у вигляді рядкаверсія()функція.


from platform import version
 
print(version())
 
Запустіть код і перевірте його вихід. Ось що ми отримали:

Intel x86 + Windows ® Vista (32 біт):
6.0.6002
Вихід
Intel x86 + Gentoo Linux (64 біт):
#1 SMP PREEMPT Fri Jul 21 22:44:37 CEST 2017
Вихід
Raspberry PI2 + Raspbian Linux (32 біт):
#1 SMP Debian 4.4.6-1+rpi14 (2016-05-05)
Вихід
Thepython_implementationіpython_version_tupleфункції
Якщо вам потрібно знати, яка версія Python використовує ваш код, ви можете перевірити це за допомогою кількох спеціальних функцій - ось дві з них:

python_implementation()→ повертає рядок, що позначає реалізацію Python (очікуєтьсяCPythonтут, якщо ви не вирішите використовувати будь-яку неканонічну гілку Python)
python_version_tuple()→ повертає триелементний кортеж, заповнений:
основна частина версії Python;
другорядна частина ;
номер рівня патча .
play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Наш приклад програми створив такий результат:

CPython
3
7
7
Вихід
Дуже ймовірно, що ваша версія Python буде іншою.
1.2.7 Індекс модуля Python
Тут ми розглянули лише основи модулів Python. Модулі Python складають свій власний всесвіт, у якому сам Python є лише галактикою, і ми ризикнемо сказати, що вивчення глибин цих модулів може зайняти значно більше часу, ніж знайомство з «чистим» Python.

Більше того, спільнота Python у всьому світі створює та підтримує сотні додаткових модулів, які використовуються в дуже нішевих програмах, таких як генетика, психологія чи навіть астрологія.

Ці модулі не поширюються (і не будуть) розповсюджуватися разом із Python або через офіційні канали, що робить всесвіт Python ширшим — майже нескінченним.

Ви можете прочитати про всі стандартні модулі Python тут: https://docs.python.org/3/py-modindex.html .


Не хвилюйтеся – усі ці модулі вам не знадобляться. Багато з них дуже специфічні.

Все, що вам потрібно зробити, це знайти потрібні модулі та навчитися ними користуватися. Це легко.

У наступному розділі ми розглянемо щось інше. Ми покажемо вам, як написати власний модуль.

1.2.8 РЕЗЮМЕ РОЗДІЛУ
1. Функція з іменемdir()може показати вам список сутностей, що містяться всередині імпортованого модуля. Наприклад:


import os
dir(os)
роздруковує список усіхосможливості модуля, які можна використовувати у своєму коді.

2. Theматематикамодуль поєднує понад 50 символів (функцій і констант), які виконують математичні операції (наприклад,синус(),pow(),факториал()) або надання важливих значень (наприклад, π і символ Ейлера e ).

3. Theвипадковий модульгрупує понад 60 сутностей, розроблених, щоб допомогти вам використовувати псевдовипадкові числа. Не забувайте про префікс «випадковий», оскільки не існує такого поняття, як справжнє випадкове число, коли справа доходить до їх генерації за допомогою комп’ютерних алгоритмів.

4. TheплатформаМодуль містить близько 70 функцій, які дозволяють зануритися в базові рівні ОС і апаратного забезпечення. Їх використання дає змогу більше дізнатися про середовище, у якому виконується ваш код.

5. Індекс модулів Python ( https://docs.python.org/3/py-modindex.html – це керований спільнотою каталог модулів, доступних у всесвіті Python. Якщо ви хочете знайти модуль, який відповідає вашим потребам, почніть свій пошукайте там.

1.3.1 Що таке пакет?
Написання власних модулів мало чим відрізняється від написання звичайних скриптів.

Є деякі особливі аспекти, про які ви повинні знати, але це точно не ракетобудування. Ви скоро це побачите.

Давайте підсумуємо деякі важливі питання:

модуль - це свого роду контейнер, наповнений функціями - ви можете упакувати скільки завгодно функцій в один модуль і розповсюдити його по всьому світу;
звичайно, як правило, це гарна ідея не змішувати функції з різними сферами застосування в одному модулі (так само, як у бібліотеці - ніхто не очікує, що наукові роботи будуть розміщені серед коміксів), тому ретельно групуйте свої функції та називайте модуль, який їх містить, у чітким та інтуїтивно зрозумілим способом (наприклад, не вказуйте назвуarcade_gamesдо модуля, що містить функції, призначені для розділення та форматування жорстких дисків)
![img_3.png](img_3.png)

створення багатьох модулів може спричинити невеликий безлад - рано чи пізно ви захочете згрупувати свої модулі точно так само, як ви раніше групували функції - чи існує більш загальний контейнер, ніж модуль?
так, є - це пакет ; у світі модулів пакет відіграє подібну роль до папки/каталогу у світі файлів.

1.3.2 Ваш перший модуль
Крок 1
У цьому розділі ви працюватимете локально на своїй машині. Почнемо з нуля. Створіть порожній файл, ось так:


 
 
module.py
Для повторення цих експериментів вам знадобляться два файли. Першим з них буде сам модуль. Зараз порожньо. Не хвилюйтеся, незабаром ви заповните його фактичним кодом.

Ми назвали файлmodule.py. Не дуже креативно, але просто і зрозуміло.

Крок 2
Другий файл містить код використання нового модуля. Його назва main.py. Його зміст поки дуже короткий:


import module
 
main.py
Примітка: обидва файли мають бути в одній папці. Ми настійно рекомендуємо вам створити порожню нову папку для обох файлів. Тоді деякі речі будуть легшими.

Запустіть IDLE (або будь-яку іншу IDE, яку ви віддаєте перевагу) і запустіть файл main.py. Що ти бачиш?

Ви не повинні нічого бачити. Це означає, що Python успішно імпортував вміст файлу module.py .

Неважливо, що модуль поки порожній. Перший крок зроблено, але перш ніж зробити наступний крок, ми хочемо, щоб ви заглянули в папку, в якій знаходяться обидва файли.

Помітили щось цікаве?

З’явилася нова вкладена папка – ви її бачите? Його назва __pycache__ . Зазирніть всередину. Що ти бачиш?

Існує файл із назвою (більш-менш) module.cpython-xy.pyc , де x і y є цифрами, отриманими з вашої версії Python (наприклад, вони будуть 3 і 8, якщо ви використовуєте Python 3.8).

Назва файлу збігається з назвою вашого модуля (модуль тут). Частина після першої крапки вказує, яка реалізація Python створила файл ( тут CPython ) і номер його версії. Остання частина ( pyc ) походить від слів Python і скомпільований .

Ви можете зазирнути всередину файлу – вміст абсолютно нерозбірливий для людини. Це має бути так, оскільки файл призначений лише для використання Python.

Коли Python імпортує модуль вперше, він перетворює його вміст у дещо скомпільовану форму .

Файл не містить машинного коду – це внутрішній напівскомпільований код Python , готовий до виконання інтерпретатором Python. Таким чином, файл не вимагає багато перевірок, необхідних для чистого вихідного файлу, виконання починається швидше, і він також працює швидше.

Завдяки цьому кожен наступний імпорт відбуватиметься швидше, ніж інтерпретація вихідного тексту з нуля.

Python може перевірити, чи було змінено вихідний файл модуля (у цьому випадку файл pyc буде перебудовано) чи ні (у цьому випадку файл pyc можна запустити одразу). Оскільки цей процес є повністю автоматичним і прозорим, вам не потрібно пам’ятати про це.

Крок 3
Тепер ми додали дещо у файл модуля:


print("I like to be a module.")
 
module.py
Чи можете ви помітити відмінності між модулем і звичайним скриптом? Поки що їх немає.

Цей файл можна запустити як будь-який інший сценарій. Спробуйте самі.

Що сталося? Ви повинні побачити наступний рядок у вашій консолі:

I like to be a module.
 
Вихід
Крок 4
Повернемося доmain.pyфайл:


import module
 
main.py
Запустіть його. Що ти бачиш? Сподіваємося, ви побачите щось подібне:

I like to be a module.
 
Вихід
Що це насправді означає?

Коли модуль імпортується, його вміст неявно виконується Python . Це дає модулю можливість ініціалізувати деякі його внутрішні аспекти (наприклад, він може призначити деяким змінним корисні значення).

Примітка: ініціалізація відбувається лише один раз , коли відбувається перший імпорт, тому призначення, виконані модулем, не повторюються без потреби.

Уявіть такий контекст:

є модуль з назвою mod1 ;
є модуль під назвою mod2 , який міститьімпорт mod1інструкція;
є головний файл, що міститьімпорт mod1іімпорт mod2інструкції.
На перший погляд ви можете подумати, що mod1 буде імпортовано двічі - на щастя, відбувається лише перший імпорт . Python запам’ятовує імпортовані модулі та мовчки пропускає всі наступні імпорти.

Крок 5
Але Python робить набагато більше, ніж просто імпортує модуль. Він також створює змінну під назвою__ім'я__.

Крім того, кожен вихідний файл використовує власну, окрему версію змінної – вона не використовується спільно для модулів.

Ми покажемо вам, як ним користуватися. Трохи змініть модуль:


print("I like to be a module.")
print(__name__)
module.py
Тепер запустітьmodule.pyфайл. Ви повинні побачити такі рядки:

I like to be a module
__main__
Вихід
Тепер запустіть файл main.py. і? Ви бачите те саме, що й ми?

I like to be a module
module
Вихід
Ми можемо сказати, що:

коли ви запускаєте файл безпосередньо, його__ім'я__змінна має значення__основний__;
коли файл імпортується як модуль, його__ім'я__змінна встановлюється на ім’я файлу (за винятком .py )
Крок 6
Ось як ви можете використовувати__основний__змінна, щоб визначити контекст, у якому було активовано ваш код:


if __name__ == "__main__":
   print("I prefer to be a module.")
else:
   print("I like to be a module.")
 
module.py
Однак існує більш розумний спосіб використовувати змінну. Якщо ви пишете модуль, наповнений кількома складними функціями, ви можете використовувати його для розміщення серії тестів, щоб перевірити, чи функції працюють належним чином.

Кожного разу, коли ви змінюєте будь-яку з цих функцій, ви можете просто запустити модуль, щоб переконатися, що ваші поправки не зіпсували код. Ці тести будуть пропущені, коли код буде імпортовано як модуль.

Крок 7
Цей модуль міститиме дві прості функції, і якщо ви хочете знати, скільки разів функції були викликані, вам потрібен лічильник, ініціалізований нулем під час імпорту модуля.

Ви можете зробити це таким чином:


counter = 0
   
if __name__ == "__main__":
   print("I prefer to be a module.")
else:
   print("I like to be a module.")
 
module.py
Крок 8
Введення такої змінної є абсолютно правильним, але може спричинити важливі побічні ефекти, про які ви повинні знати.

Подивіться на модифікованийmain.pyфайл:


import module
print(module.counter)
  
main.py
Як бачите, головний файл намагається отримати доступ до змінної лічильника модуля. Це законно? Так. Чи можна його використовувати? Це може бути дуже корисним. це безпечно?

Це залежить від того – якщо ви довіряєте користувачам свого модуля, проблем не буде; однак ви можете не захотіти, щоб решта світу бачив вашу особисту/приватну змінну .

На відміну від багатьох інших мов програмування, Python не має засобів, які дозволяють приховати такі змінні від очей користувачів модуля.

Ви можете лише повідомити своїх користувачів, що це ваша змінна, що вони можуть її читати, але не повинні змінювати її за жодних обставин.

Це робиться, якщо перед назвою змінної ставиться_(одне підкреслення) або__(два підкреслення), але пам’ятайте, що це лише домовленість . Користувачі вашого модуля можуть підкорятися йому, а можуть і ні.

Звичайно, ми будемо дотримуватися конвенції. Тепер давайте розмістимо дві функції в модулі – вони будуть обчислювати суму та добуток чисел, зібраних у списку.

Крім того, додамо туди якісь прикраси і приберемо зайве.

Крок 9
Гаразд. Давайте напишемо новий код у нашомуmodule.pyфайл. Оновлений модуль готовий тут:


#!/usr/bin/env python3
 
"" module.py - an example of a Python module ""
 
__counter = 0
 
 
def suml(the_list):
  global __counter
  __counter += 1
  the_sum = 0
  for element in the_list:
   the_sum += element
  return the_sum
 
 
def prodl(the_list):
  global __counter
  __counter += 1
  prod = 1
  for element in the_list:
   prod *= element
  return prod
 
 
if __name__ == "__main__":
  print("I prefer to be a module, but I can do some tests for you.")
  my_list = [i+1 for i in range(5)]
  print(suml(my_list) == 15)
  print(prodl(my_list) == 120)
  
module.py
На нашу думку, деякі елементи потребують пояснення:

рядок, що починається з#!має багато назв - його можна назвати shabang , shebang , hashbang , poundbang або навіть hashpling (не питайте нас чому). Сама назва тут нічого не означає - важливіша її роль. З точки зору Python, це лише коментар , з якого він починається#. Для Unix і Unix-подібних ОС (включаючи MacOS) такий рядок вказує ОС, як виконати вміст файлу (іншими словами, яку програму потрібно запустити для інтерпретації тексту). У деяких середовищах (особливо тих, які пов’язані з веб-серверами) відсутність цього рядка спричинить проблеми;
рядок (можливо, багаторядковий), розміщений перед будь-якими інструкціями модуля (включно з імпортом), називається doc-string і має коротко пояснювати призначення та вміст модуля;
функції, визначені всередині модуля (suml()іprodl()) доступні для імпорту;
ми використовували__ім'я__змінна, щоб визначити, коли файл запускається автономно, і скористався цією можливістю, щоб виконати кілька простих тестів.
Крок 10
Тепер можна використовувати оновлений модуль - це один із способів:


from module import suml, prodl
 
zeroes = [0 for i in range(5)]
ones = [1 for i in range(5)]
print(suml(zeroes))
print(prodl(ones))
 
main.py
Крок 11
Настав час ускладнити наш приклад - поки що ми припускали, що основний файл Python знаходиться в тій же папці/каталозі, що й модуль, який потрібно імпортувати.

Давайте відмовимося від цього припущення та проведемо такий уявний експеримент:

ми використовуємо ОС Windows® (це припущення важливе, оскільки від нього залежить форма імені файлу)
основний скрипт Python знаходиться в C:\Users\user\py\progs і називається main.py
модуль для імпорту знаходиться в C:\Users\user\py\modules
![img_4.png](img_4.png)
Як ми з цим справляємося?

Щоб відповісти на це запитання, ми повинні поговорити про те, як Python шукає модулі . Існує спеціальна змінна (насправді список), у якій зберігаються всі розташування (папки/каталоги), у яких виконується пошук, щоб знайти модуль, який запитується інструкцією імпорту.

Python переглядає ці папки в тому порядку, у якому вони перераховані у списку – якщо модуль не знайдено в жодному з цих каталогів, імпорт не вдасться.

В іншому випадку буде взято до уваги першу папку, що містить модуль із потрібною назвою (якщо будь-яка з решти папок містить модуль із такою назвою, вона буде проігнорована).

Змінна названашлях, і він доступний через модуль під назвоюсистема. Ось як ви можете перевірити його звичайне значення:


import sys
 
for p in sys.path:
  print(p)
 
Ми запустили код у папці C:\User\user і отримали ось що:

C:∖Users∖user
C:∖Users∖user∖AppData∖Local∖Programs∖Python∖Python36-32∖python36.zip
C:∖Users∖user∖AppData∖Local∖Programs∖Python∖Python36-32∖lib
C:∖Users∖user∖AppData∖Local∖Programs∖Python∖Python36-32
C:∖Users∖user∖AppData∖Local∖Programs∖Python∖Python36-32∖lib∖site-packages
Вихід
Примітка: папка, у якій починається виконання, указана в першому елементі шляху .

Зверніть увагу ще раз: як один із елементів шляху вказано zip-файл — це не помилка. Python може розглядати zip-файли як звичайні папки - це може заощадити багато місця.

Чи можете ви зрозуміти, як ми можемо вирішити нашу проблему зараз? Ми можемо додати папку, що містить модуль, до змінної path (її можна повністю змінювати).

Крок 12
Одне з кількох можливих рішень виглядає так:


from sys import path
 
path.append('..∖∖modules')
 
import module
 
zeroes = [0 for i in range(5)]
ones = [1 for i in range(5)]
print(module.suml(zeroes))
print(module.prodl(ones))
 
main.py
Примітка

ми подвоїли\внутрішня назва папки - знаєте чому?
Перевірте
ми використали відносну назву папки — це спрацює, якщо ви запускаєте файл main.py безпосередньо з його домашньої папки, і не працюватиме, якщо поточний каталог не відповідає відносному шляху; ви завжди можете використовувати абсолютний шлях, наприклад:
path.append('C:\\Users\\user\\py\\modules')
ми використовувалидодати()метод - по суті, новий шлях займе останній елемент у списку шляхів; якщо вам не подобається ідея, ви можете використовувативставити()замість цього.