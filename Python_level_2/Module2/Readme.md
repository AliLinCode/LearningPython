2.1.1 Як комп’ютери розуміють окремі символи
Ви написали кілька цікавих програм відтоді, як розпочали цей курс, але всі вони обробляли лише один вид даних – числа. Як ви знаєте (ви можете бачити це всюди навколо себе), багато комп’ютерних даних не є числами: імена, прізвища, адреси, назви, вірші, наукові статті, електронні листи, судові рішення, визнання в коханні та багато, багато іншого.


Всі ці дані повинні зберігатися, вводитися, виводитися, шукатися і перетворюватися сучасними комп'ютерами так само, як і будь-які інші дані, незалежно від того, чи це одиничні символи, чи багатотомні енциклопедії.

Як це можливо?

Як це зробити на Python? Ось про що ми зараз і поговоримо. Почнемо з того, як комп’ютери розуміють окремі символи.

Комп'ютери зберігають символи як числа . Кожен символ, який використовує комп’ютер, відповідає унікальному номеру, і навпаки. Це завдання має містити більше символів, ніж ви могли очікувати. Багато з них невидимі для людини, але необхідні комп’ютерам.

Деякі з цих символів називаються пробілами , тоді як інші називаються контрольними символами , оскільки вони призначені для керування пристроями введення/виведення.

Прикладом пробілу, абсолютно невидимого неозброєним оком, є спеціальний код або пара кодів (у різних операційних системах ця проблема може розглядатися по-різному), які використовуються для позначення кінців рядків у текстових файлах.

Люди не бачать цей знак (або ці знаки), але можуть спостерігати ефект їх нанесення там, де лінії розірвані.

Ми можемо створити практично будь-яку кількість символів-номерів, але життя у світі, де кожен тип комп’ютера використовує різне кодування символів, було б не дуже зручним. Ця система призвела до необхідності запровадження універсального та загальноприйнятого стандарту, реалізованого (майже) усіма комп’ютерами та операційними системами в усьому світі.

Код під назвою ASCII (скорочення від American Standard Code for Information Interchange ) є найпоширенішим, і ви можете припустити, що майже всі сучасні пристрої (наприклад, комп’ютери, принтери, мобільні телефони, планшети тощо) використовують цей код.

У коді передбачено простір для 256 різних символів , але нас цікавлять лише перші 128. Якщо ви хочете побачити, як побудований код, подивіться на таблицю нижче. Натисніть таблицю, щоб збільшити її. Подивіться уважно – там є цікаві факти. Подивіться на код найпоширенішого символу – пробілу . Це 32 .


![img.png](img.png)
![img_1.png](img_1.png)
Тепер перевірте код малої літери a . Це 97 . А тепер знайдіть велику букву A . Його код 65 . Тепер з’ясуйте різницю між кодом a і A . Воно дорівнює 32 . Це код пробілу . Цікаво, чи не так?

Також зауважте, що літери розташовані в тому ж порядку, що й у латинському алфавіті.
2.1.2 I18N
Звичайно, латинського алфавіту недостатньо для всього людства. Користувачі цього алфавіту в меншості. Треба було придумати щось більш гнучке і містке, ніж ASCII, щось таке, що могло б зробити все програмне забезпечення в світі піддатливим до інтернаціоналізації , тому що різні мови використовують абсолютно різні алфавіти, і часом ці алфавіти не такі прості, як латинський.

Слово інтернаціоналізація зазвичай скорочується до I18N .

чому Подивіться уважно – на початку слова стоїть І , далі 18 різних літер, а в кінці – Н.

Незважаючи на трохи жартівливе походження, термін офіційно використовується в багатьох документах і стандартах.


Програмне забезпечення I18N є стандартом в даний час. Кожна програма має бути написана таким чином, щоб її можна було використовувати в усьому світі, серед різних культур, мов та алфавітів.

Класична форма коду ASCII використовує вісім бітів для кожного знака . Вісім бітів означають 256 різних символів. Перші 128 використовуються для стандартного латинського алфавіту (як великі, так і малі символи). Чи можливо перенести всі інші національні символи, які використовуються в усьому світі, до решти 128 місць?

Ні. Це не так.

2.1.3 Кодові точки та кодові сторінки
Зараз нам потрібен новий термін: кодова точка .

Кодова точка — це число, яке створює символ . Наприклад, 32 — це кодова точка, яка робить пробіл у кодуванні ASCII. Можна сказати, що стандартний код ASCII складається з 128 кодових точок.

Оскільки стандартний ASCII займає 128 із 256 можливих кодових точок, ви можете використовувати лише решту 128.

Цього недостатньо для всіх можливих мов, але може бути достатньо для однієї мови або для невеликої групи схожих мов.

Чи можете ви по-різному встановити верхню половину кодових точок для різних мов ? Так, ти можеш. Така концепція називається кодовою сторінкою .

Кодова сторінка є стандартом для використання верхніх 128 кодових точок для зберігання певних національних символів . Наприклад, існують різні кодові сторінки для Західної та Східної Європи, кириличний і грецький алфавіти, арабська та іврит мови тощо.

Це означає, що одна й та сама кодова точка може створювати різні символи при використанні на різних кодових сторінках.

Наприклад, кодова точка 200 перетворює Č (літера, яка використовується в деяких слов’янських мовах), коли використовується кодова сторінка ISO/IEC 8859-2, і перетворюється на Ш (літера кирилиці), коли використовується код ISO/IEC 8859-5. сторінки.

Як наслідок, щоб визначити значення конкретної кодової точки, ви повинні знати цільову кодову сторінку.

Іншими словами, кодові точки, отримані з концепції кодової сторінки, неоднозначні.


Unicode
Кодові сторінки деякий час допомогли комп’ютерній індустрії вирішити проблеми I18N, але незабаром виявилося, що вони не будуть постійним рішенням.

Концепцією, яка вирішила проблему в довгостроковій перспективі, був Unicode .

Юнікод призначає унікальні (однозначні) символи (літери, дефіси, ідеограми тощо) більш ніж мільйону кодових точок .


Перші 128 кодових точок Unicode ідентичні ASCII, а перші 256 кодових точок Unicode ідентичні кодовій сторінці ISO/IEC 8859-1 (кодова сторінка, розроблена для західноєвропейських мов).

UCS-4
Стандарт Unicode нічого не говорить про те, як кодувати та зберігати символи в пам’яті та файлах. Він лише називає всі доступні символи та призначає їх площинам (групі символів подібного походження, застосування чи природи).

Існує більше ніж один стандарт, що описує методи, які використовуються для реалізації Unicode в реальних комп’ютерах і комп’ютерних системах зберігання. Найзагальнішим з них є UCS-4 .

Назва походить від універсального набору символів .


UCS-4 використовує 32 біти (чотири байти) для зберігання кожного символу , а код — це лише унікальний номер кодових точок Unicode. Файл, що містить текст у кодуванні UCS-4, може починатися з позначки порядку байтів (BOM), непридатної для друку комбінації бітів, яка повідомляє про природу вмісту файлу. Це може знадобитися деяким утилітам.

Як бачите, UCS-4 є досить марнотратним стандартом - він збільшує розмір тексту в чотири рази порівняно зі стандартним ASCII. На щастя, існують розумніші форми кодування текстів Unicode.

UTF-8
Одним із найпоширеніших є UTF-8 .

Назва походить від формату перетворення Юнікоду .

Концепція дуже розумна. UTF-8 використовує стільки бітів для кожної точки коду, скільки дійсно потрібно для їх представлення .

Наприклад:

усі латинські символи (і всі стандартні символи ASCII) займають вісім біт;
нелатинські символи займають 16 біт;
Ідеографи CJK (Китай-Японія-Корея) займають 24 біти.

Через особливості методу, який використовується UTF-8 для зберігання кодових точок, немає необхідності використовувати специфікацію, але деякі інструменти шукають її під час читання файлу, і багато редакторів налаштовують її під час збереження.

Python 3 повністю підтримує Unicode та UTF-8:

ви можете використовувати символи в кодуванні Unicode/UTF-8 для іменування змінних та інших об’єктів;
ви можете використовувати їх протягом усього введення та виведення.
Це означає, що Python3 є повністю I18Ned.

Неповний 

2.1.4 РЕЗЮМЕ РОЗДІЛУ
1. Комп’ютери зберігають символи як числа. Існує більше ніж один можливий спосіб кодування символів, але лише деякі з них набули всесвітньої популярності та широко використовуються в ІТ: це ASCII (використовується в основному для кодування латинського алфавіту та деяких його похідних) і UNICODE (може кодувати віртуально всі алфавіти, якими користуються люди).

2. Число, що відповідає певному символу, називається кодовою точкою .

3. UNICODE використовує різні способи кодування, коли йдеться про зберігання символів у файлах або пам’яті комп’ютера: два з них – UCS-4 та UTF-8 (останній є найпоширенішим, оскільки він витрачає менше пам’яті).
Це твердження означає, що Python3 повністю підтримує інтернаціоналізацію (I18N).

Що таке інтернаціоналізація (I18N)?
Інтернаціоналізація (I18N) — це процес розробки програмного забезпечення таким чином, щоб воно могло легко підтримувати різні мови і регіональні налаштування без необхідності вносити зміни в код програми. Назва "I18N" походить від скорочення слова "Internationalization", де "I" — перша літера, "N" — остання, а між ними 18 літер.

Що означає, що Python3 є повністю I18Ned?
Це означає, що Python3 має вбудовану підтримку для роботи з різними мовами та регіональними налаштуваннями. Зокрема, Python3:

Підтримка Unicode: Python3 використовує Unicode для представлення рядків тексту, що дозволяє легко працювати з текстом на будь-якій мові.

Модулі для роботи з локалізацією: Python3 має вбудовані модулі, такі як locale, gettext та інші, які допомагають у роботі з локалізацією програм (переклад тексту, форматування чисел, дат тощо).

Форматування рядків: Python3 підтримує різні способи форматування рядків, що полегшує їх локалізацію. Наприклад, методи format() та F-рядки (f-strings).

Бібліотеки: Існує багато бібліотек сторонніх розробників, які допомагають у процесі інтернаціоналізації та локалізації, наприклад, babel.

Приклад використання інтернаціоналізації в Python3
Ось простий приклад використання модуля gettext для локалізації тексту:

python
Копіювати код
import gettext
import locale

# Встановлюємо локаль
locale.setlocale(locale.LC_ALL, '')

# Встановлюємо каталог з перекладами
localedir = 'locale'
lang = gettext.translation('myapp', localedir, languages=['es'])
lang.install()

# Використовуємо функцію _() для перекладу
print(_('Hello, World!'))
Цей приклад передбачає, що у вас є каталог з перекладами locale, де знаходяться файли перекладів для вашої програми.

Таким чином, коли ми говоримо, що Python3 є повністю I18Ned, це означає, що мова надає всі необхідні інструменти та можливості для розробки програм, які легко адаптуються до різних мов та культур.

2.2.1 Рядки - короткий огляд
Давайте коротко розглянемо природу рядків Python.

Перш за все, рядки Python (або просто рядки, оскільки ми не збираємося обговорювати рядки інших мов) є незмінними послідовностями .

Це дуже важливо звернути увагу, оскільки це означає, що ви повинні очікувати від них деякої знайомої поведінки.

Давайте розберемо код у редакторі, щоб зрозуміти, про що ми говоримо:

Подивіться на приклад 1 . The len()функція, яка використовується для рядків, повертає кількість символів, що містяться в аргументах. Вихідні фрагменти2.
Будь-який рядок може бути порожнім. Його довжина становить0потім – як у прикладі 2 .
Не забувайте, що зворотна коса риска (\), який використовується як контрольний символ, не входить до загальної довжини рядка. Таким чином, код у прикладі 3 виводить3.
Запустіть три приклади кодів і перевірте.


2.2.2 Багаторядкові рядки
Зараз дуже вдалий момент, щоб показати вам інший спосіб визначення рядків у вихідному коді Python. Зверніть увагу, що синтаксис, який ви вже знаєте, не дозволить використовувати рядок, який займає більше одного рядка тексту.

З цієї причини код тут є помилковим:

multiline = 'Рядок №1
Лінія №2'

print(len(multiline))

На щастя, для таких рядків Python пропонує окремий, зручний і простий синтаксис.


Подивіться на код у редакторі. Ось як це виглядає.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
multiline = '''Line #1


Консоль 
термінал
синхронізація
15
15

Як бачите, рядок починається з трьох апострофів , а не з одного. Для його закінчення використовується той самий потрійний апостроф.

Кількість рядків тексту, що поміщаються в такий рядок, є довільною.

Вихідні фрагменти15.

Уважно порахуйте символи. Цей результат правильний чи ні? На перший погляд це виглядає добре, але коли порахувати персонажів, це не так.

Лінія №1містить сім символів. Два таких рядки складаються з 14 символів. Ми втратили характер? де як?

Ні, не робили.

Відсутній символ просто невидимий – це пробіл . Він розташований між двома рядками тексту.

Це позначається як:\n.

Ти пам'ятаєш? Це спеціальний (керуючий) символ, який використовується для примусового переходу рядка (звідси його назва: LF). Ви не бачите, але це має значення.

Багаторядкові рядки також можуть бути розділені потрійними лапками , як тут:


multiline = """Line #1
Line #2"""
 
print(len(multiline))
 

Виберіть зручний для вас спосіб. Обидва працюють однаково.

2.2.3 Операції над рядками
Як і інші типи даних, рядки мають власний набір дозволених операцій, хоча вони досить обмежені порівняно з числами.

Загалом рядки можуть бути:

об'єднаний (з'єднаний)
тиражований .
Першу операцію виконує+оператор (примітка: це не додавання), тоді як другий оператором*оператор (ще раз зауважте: це не множення).

Можливість використовувати той самий оператор проти абсолютно різних типів даних (наприклад, чисел проти рядків) називається перевантаженням (оскільки такий оператор перевантажений різними обов’язками).

Проаналізуйте приклад:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
аб
ба
ааааа
bbbb
аб
ба
ааааа
bbbb

The+оператор, що використовується проти двох або більше рядків, створює новий рядок, що містить усі символи з його аргументів (примітка: порядок має значення – це перевантажено+, на відміну від свого числового варіанту, не є комутативним )
в*оператору потрібні рядок і число як аргументи; у цьому випадку порядок не має значення – ви можете поставити число перед рядком, або навпаки, результат буде той самий – новий рядок, створений n-ою копією рядка аргументу.
Подивіться на рядок коду нижче:
Фрагмент дає такий результат:

ab
ba
aaaaa
bbbb
Вихід
Примітка: скорочені варіанти наведених вище операторів також застосовуються до рядків (+=і*=).

ord()
Якщо ви хочете дізнатися значення коду ASCII/UNICODE певного символу , ви можете скористатися функцією під назвоюord()(як у порядковому ).

Функції потрібен односимвольний рядок як аргумент – порушення цієї вимоги спричиняє виняток TypeError і повертає число, що представляє кодову точку аргументу.

Перегляньте код у редакторі та запустіть його.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
97
32

Фрагмент виводить:

97
32
Вихід
Тепер призначте інші значенняchar_1іchar_2, наприклад,α(грец. alpha), іę(літера польського алфавіту); потім запустіть код і подивіться, який результат він виведе. Проведіть власні досліди.

chr()
Якщо ви знаєте кодову точку (число) і хочете отримати відповідний символ, ви можете скористатися функцією з назвоюchr().

Функція приймає кодову точку та повертає її символ .

Виклик його з недійсним аргументом (наприклад, негативний або недійсний код) викликає винятки ValueError або TypeError .

Запустіть код у редакторі.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Приклад фрагмента виводить:

a
α
Вихід
Примітка:

chr(ord(x)) == x
ord(chr(x)) == x
Знову ж таки, проведіть власні експерименти.

2.2.4 Рядки як послідовності
Індексація
Раніше ми казали вам, що рядки Python є послідовностями . Настав час показати вам, що це насправді означає.

Рядки не є списками, але ви можете розглядати їх як списки в багатьох конкретних випадках .

Наприклад, якщо ви хочете отримати доступ до будь-якого символу рядка, ви можете зробити це за допомогою індексування , як у прикладі нижче. Запустіть програму:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
безглузді походи 

Будьте обережні – не намагайтеся перейти за межі рядка – це спричинить виключення.

Подивіться на рядок коду нижче:
Приклад результату:

s i l l y   w a l k s
Вихід
До речі, негативні показники теж поводяться очікувано. Перевірте це самі.

Ітерація
Ітерація рядків теж працює. Подивіться на приклад нижче:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
безглузді походи 

Результат такий же, як і раніше. Перевірте.

2.2.5 Зрізи
Крім того, все, що ви знаєте про скибочки, все ще придатне для використання.

Ми зібрали кілька прикладів, які показують, як працюють зрізи у світі рядків. Перегляньте код у редакторі, проаналізуйте його та запустіть.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
бд
efg
абд
д
д
присл
просити

Ви не побачите нічого нового в прикладі, але ми хочемо, щоб ви були впевнені, що можете пояснити всі рядки коду.

Вихід коду:

bd
efg
abd
e
e
adf
beg
Вихід
А тепер проведіть власні експерименти.

2.2.6 Оператори in та not in
Оператор in​
TheвОператор не повинен вас здивувати, якщо його застосувати до рядків – він просто перевіряє, чи його лівий аргумент (рядок) можна знайти будь-де в межах правого аргументу (іншого рядка) .

Результат перевірки простийправдаабопомилковий.

Подивіться приклад програми нижче. Ось яквпрацює оператор:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
правда
помилковий
помилковий
правда
помилковий

Подивіться на рядок коду нижче:
Приклад результату:

True
False
False
True
False
Вихід
Не в оператора
Як ви, мабуть, підозрюєте,не втут також застосовний оператор.

Ось як це працює:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Приклад результату:

False
True
True
False
True
Вихід

2.2.7 Рядки Python незмінні
Ми також говорили вам, що рядки Python незмінні . Це дуже важлива функція. Що це означає?

Це в першу чергу означає, що подібність рядків і списків обмежена. Не все, що ви можете зробити зі списком, можна зробити з рядком.

Перша важлива відмінність не дозволяє вам використовуватиделінструкція для видалення будь-чого з рядка .

Приклад тут не працюватиме:

alphabet = "abcdefghijklmnopqrstuvwxyz"
del alphabet[0]
 
Єдине, що ви можете зробити здела рядок — це видалити рядок у цілому . Спробуйте це зробити.


Рядки Python не маютьдодати()метод – ви не можете розширити їх жодним чином.

Наведений нижче приклад є помилковим:

alphabet = "abcdefghijklmnopqrstuvwxyz"
alphabet.append("A")
 

з відсутністю вдодати()метод, ввставити()метод також є незаконним:

alphabet = "abcdefghijklmnopqrstuvwxyz"
alphabet.insert(0, "A")
 
Не думайте, що незмінність рядка обмежує вашу здатність працювати з рядками.

Єдиним наслідком є ​​те, що ви повинні пам’ятати про це та реалізувати свій код дещо іншим способом – подивіться приклад коду в редакторі.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Ця форма коду цілком прийнятна, працюватиме, не порушуючи правил Python, і відображатиме повний латинський алфавіт на вашому екрані:

abcdefghijklmnopqrstuvwxyz
Вихід
Ви можете запитати, чи створення нової копії рядка кожного разу, коли ви змінюєте його вміст, погіршує ефективність коду .

Так. Трохи. Однак це зовсім не проблема.

2.2.8 Операції над рядками: продовження
хв()
Тепер, коли ви розумієте, що рядки — це послідовності, ми можемо показати вам деякі менш очевидні можливості послідовностей. Ми представимо їх за допомогою рядків, але не забувайте, що списки також можуть застосовувати ті ж прийоми.

Почнемо з функції під назвоюхв().

Функція знаходить мінімальний елемент послідовності, переданий як аргумент . Є одна умова – послідовність (рядок, список, не має значення) не може бути порожньою , інакше ви отримаєте виняток ValueError .

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Програма прикладу 1 виводить:

A
Вихід
Примітка. Це A у верхньому регістрі . чому Згадайте таблицю ASCII – які літери займають перші місця – верхні чи нижні?

Ми підготували ще два приклади для аналізу: Приклади 2 і 3 .

Як бачите, вони представляють не просто рядки. Очікуваний результат виглядає наступним чином:

[ ]
0
Вихід
Примітка: ми використали квадратні дужки, щоб запобігти пропуску місця на екрані.

max()
Подібним чином функція з назвоюmax() знаходить максимальний елемент послідовності .

Подивіться приклад 1 у редакторі.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Примітка. Це буква z у нижньому регістрі .

Тепер давайте подивимосяmax()функція застосована до тих самих даних, що й раніше. Перегляньте приклади 2 і 3 у редакторі.

Очікуваний результат:

[y]
2
Вихід
Проведіть власні досліди.

Метод index ().
Theіндекс()метод (це метод, а не функція) шукає послідовність з початку, щоб знайти перший елемент значення, указаного в його аргументі .

Примітка: шуканий елемент має бути в послідовності – його відсутність спричинить виняток ValueError .

Метод повертає індекс першого входження аргументу (це означає, що найменший можливий результат дорівнює 0 , а найвищий – це довжина аргументу, зменшена на 1 ).

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Таким чином, приклад у редакторі виводить:

2
7
1
Вихід
Функція list ().
Theсписок()функція приймає свій аргумент (рядок) і створює новий список, що містить усі символи рядка, по одному на елемент списку .

Примітка: це не суто функція рядка -список()може створювати новий список з багатьох інших сутностей (наприклад, з кортежів і словників).

Подивіться на приклад коду в редакторі.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Приклад виводить:

['a', 'b', 'c', 'a', 'b', 'c']
Вихід
Метод count ().
Theрахувати()метод підраховує всі входження елемента в послідовність . Відсутність таких елементів не викликає проблем.

Подивіться на другий приклад у редакторі. Чи можете ви вгадати його результат?

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Це є:

2
0
Вихід
Крім того, рядки Python мають значну кількість методів, призначених виключно для обробки символів. Не очікуйте, що вони працюватимуть з іншими колекціями. Повний список представлений тут: https://docs.python.org/3.4/library/stdtypes.html#string-methods .

Ми покажемо вам ті, які ми вважаємо найкориснішими.

Неповний 
2.2.9 РЕЗЮМЕ РОЗДІЛУ
2.2.9 РЕЗЮМЕ РОЗДІЛУ
1. Рядки Python є незмінними послідовностями , їх можна індексувати, нарізати та повторювати, як і будь-яку іншу послідовність, а також підлягативіне воператори. У Python є два види рядків:

однорядкові рядки , які не можуть перетинати межі рядків – ми їх позначаємо або апострофами (рядок) або цитати ("рядок")
багаторядкові рядки, які займають більше одного рядка вихідного коду, розділених триграфами:
'''
рядок
'''

або

"""
рядок
"""

2. Довжина рядка визначаєтьсяlen()функція. Персонаж втечі (\) не враховується. Наприклад:


print(len("\n\n"))
 
виходи2.

3. Рядки можна об'єднати за допомогою+і реплікується за допомогою*оператор. Наприклад:


asterisk = '*'
plus = "+"
decoration = (asterisk + plus) * 4 + asterisk
print(decoration)
 
виходи*+*+*+*+*.

4. Пара функційchr()іord()можна використовувати для створення символу за допомогою його кодової точки та для визначення кодової точки, що відповідає символу. Обидва наступних виразу завжди вірні:


chr(ord(character)) == character
ord(chr(codepoint)) == codepoint
 

5. Деякі інші функції, які можна застосувати до рядків:

список()– створює список, що складається з усіх символів рядка;
max()– знаходить символ із максимальною кодовою точкою;
хв()– знаходить символ із мінімальною кодовою точкою.

6. Спосіб іміндекс()знаходить індекс заданого підрядка всередині рядка.

2.3.1 Метод capitalize().
Давайте розглянемо деякі стандартні рядкові методи Python. Ми розглянемо їх в алфавітному порядку – чесно кажучи, будь-який порядок має стільки ж недоліків, скільки переваг, тому вибір також може бути випадковим.

Theкапіталізувати()метод робить саме те, що він каже – він створює новий рядок, заповнений символами, взятими з вихідного рядка , але намагається змінити їх у такий спосіб:

якщо перший символ у рядку є літерою (примітка: перший символ є елементом з індексом, рівним 0 , а не лише першим видимим символом), він буде перетворений у верхній регістр ;
усі літери рядка, що залишилися, будуть перетворені на малі .
Не забувайте, що:

вихідний рядок, з якого викликається метод, жодним чином не змінюється – незмінність рядка повинна дотримуватися без застережень;
змінений рядок (у цьому випадку написаний великими літерами) повертається як результат – якщо ви не використаєте його жодним чином (призначите його змінній або передасте функції/методу), він зникне без сліду.
Примітка: методи не потрібно викликати лише зі змінних. Їх можна викликати безпосередньо з рядкових літералів. Ми будемо використовувати цю умовність регулярно – це спростить приклади, оскільки найважливіші аспекти не зникнуть серед непотрібних завдань.

Подивіться на приклад у редакторі. Запустіть його.

play_arrow
sync
download
light_mode
dark_mode
Консоль 
terminal
sync

Ось що він друкує:

Abcd
Вихід
Спробуйте кілька складніших прикладів і перевірте їхні результати:

play_arrow
sync
download
light_mode
dark_mode
Консоль 
terminal
sync

2.3.2 Метод center().
Однопараметричний варіантцентр()методстворює копію вихідного рядка, намагаючись розташувати його всередині поля заданої ширини.

Фактично центрування виконується додаванням пробілів перед і після рядка .

Не очікуйте, що цей метод продемонструє будь-які складні навички. Це досить просто.

У прикладі в редакторі використовуються дужки, щоб чітко показати вам, де фактично починається і де закінчується центрований рядок.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Його вихід виглядає наступним чином:

[  alpha   ]
Вихід
Якщо довжина цільового поля занадто мала, щоб поміститися в рядок, повертається вихідний рядок.

Ви можете побачитицентр()у додаткових прикладах тут:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Запустіть наведені вище фрагменти та перевірте, який результат вони створюють.


Двопараметричний варіантцентр()використовує символ із другого аргументу замість пробілу . Проаналізуйте приклад нижче:


print('[' + 'gamma'.center(20, '*') + ']')
 
Ось чому результат тепер виглядає так:

[*******gamma********]
Вихід
Проведіть більше експериментів.

2.3.3 Метод endswith().
Theendswith()метод перевіряє, чи даний рядок закінчується вказаним аргументом, і повертаєправдаабопомилковийзалежно від результату перевірки.

Примітка: підрядок має відповідати останньому символу рядка – він не може бути розташований десь біля кінця рядка.

Подивіться на наш приклад у редакторі, проаналізуйте його та запустіть.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Він виводить:

yes
Вихід
Тепер ви зможете передбачити вихід фрагмента нижче:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Запустіть код, щоб перевірити свої прогнози.

2.3.4 Метод find().
Theзнайти()метод схожий наіндекс(), який ви вже знаєте – він шукає підрядок і повертає індекс першого входження цього підрядка , але:

це безпечніше – воно не генерує помилку для аргументу, що містить неіснуючий підрядок (він повертає-1потім)
він працює лише з рядками – не намагайтеся застосувати його до будь-якої іншої послідовності.
Подивіться на код у редакторі. Ось як ви можете його використовувати.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Приклад друкує:

1
-1
Вихід
Примітка: не використовуйтезнайти()якщо ви хочете лише перевірити, чи зустрічається один символ у рядку - theвоператор буде значно швидшим.

Ось інший приклад:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Чи можете ви передбачити результат? Запустіть і перевірте свої прогнози.


Якщо ви хочете виконати пошук не з початку рядка, а з будь-якої позиції , ви можете використовувати двопараметричний варіантзнайти()метод. Подивіться на приклад:


print('kappa'.find('a', 2))
 
Другий аргумент визначає індекс, з якого буде розпочато пошук (він не обов’язково повинен поміщатися в рядок).

Серед двох букв а знайдеться лише друга. Запустіть фрагмент і перевірте.


Ви можете використовувати знайти()метод для пошуку всіх входжень підрядка, як тут:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Код друкує індекси всіх входжень статті the , і його вихід виглядає так:

15
80
198
221
238
Вихід

Існує також трипараметрична мутаціязнайти()метод – третій аргумент вказує на перший індекс, який не буде враховано під час пошуку (фактично це верхня межа пошуку).

Подивіться на наш приклад нижче:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Другий аргумент визначає індекс, з якого буде розпочато пошук (він не обов’язково повинен поміщатися в рядок).

Таким чином, модифікований приклад виводить:

1
-1
Вихід
( a не можна знайти в заданих межах пошуку в другомудрукувати().
2.3.5 Метод isalnum().
Назва безпараметричного методуisalnum() перевіряє, чи рядок містить лише цифри або букви (літери), і повертаєправдаабопомилковийвідповідно до результату.

Перегляньте приклад у редакторі та запустіть його.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
True
True
True
False
False
False

Примітка: будь-який елемент рядка, який не є цифрою чи літерою, спричиняє повернення методупомилковий. Порожній рядок також.

Приклад результату:

True
True
True
False
False
False
Вихід

Ось ще три інтригуючих приклади:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Запустіть їх і перевірте їх результат.

Підказка: причиною першого результату є пробіл – це не цифра і не буква.



Ось ще три інтригуючих приклади:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Запустіть їх і перевірте їх результат.

Підказка: причиною першого результату є пробіл – це не цифра і не буква.

2.3.6 Метод isalpha().
Theisalpha()метод більш спеціалізований – його цікавлять лише літери .

Подивіться приклад у редакторі:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
True
False

Його вихід:

True
False
Вихід

2.3.7 Метод isdigit().
У свою чергу,isdigit()метод розглядає лише цифри – все інше створюєпомилковийяк результат.

Подивіться приклад у редакторі:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Його вихід:

True
False
Вихід
Проведіть більше експериментів.

2.3.8 Метод islower().
Theislower()метод є метушливим варіантомisalpha()– приймає лише малі літери .

Подивіться приклад у редакторі:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Він виводить:

False
True
Вихід
2.3.9 Метод isspace().
Theisspace()метод ідентифікує лише пробіли – він ігнорує будь-які інші символи (результатпомилковийпотім).

Подивіться приклад у редакторі:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Результат:

True
True
False
Вихід
2.3.10 Метод isupper().
Theisupper()метод є версією у верхньому регістріislower()– він зосереджується лише на великих літерах .

Знову подивіться на код у редакторі:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Приклад дає такий результат:

False
False
True

2.3.11 Метод join().
Theприєднатися()метод досить складний, тому давайте розповімо вам крок за кроком:

як випливає з назви, метод виконує об’єднання – він очікує один аргумент як список; необхідно переконатися, що всі елементи списку є рядками – інакше метод викличе виняток TypeError ;
усі елементи списку будуть об’єднані в один рядок, але...
... рядок, з якого було викликано метод, використовується як роздільник , розміщений серед рядків;
у результаті повертається новостворений рядок.
Подивіться на приклад у редакторі:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Давайте розберемо його:

вприєднатися()метод викликається з рядка, що містить кому (рядок може бути як завгодно довгим або порожнім)
вприєднатисяаргументом є список, що містить три рядки;
метод повертає новий рядок.
Ось:

omicron,pi,rho
Вихід
2.3.12 Метод lower().
Theнижчий()робить копію вихідного рядка, замінює всі літери у верхньому регістрі на відповідники в нижньому регістрі та повертає рядок як результат. Знову ж таки, вихідний рядок залишається недоторканим.

Якщо рядок не містить символів верхнього регістру, метод повертає оригінальний рядок.

Примітканижчий()метод не приймає жодних параметрів.

Подивіться на приклад у редакторі:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Він виводить:

sigma=60
Вихід
Як завжди, проведіть власні досліди.

2.3.13 Метод lstrip().
Безпараметрична версіяlstrip()метод повертає щойно створений рядок, утворений з оригінального шляхом видалення всіх пробілів на початку .

Проаналізуйте приклад коду в редакторі.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Дужки не є частиною результату – вони лише показують межі результату.

Приклад виводить:

[tau ]

Однопараметрична версія​lstrip()метод робить те саме, що й його версія без параметрів, але видаляє всі символи, зараховані в його аргумент (рядок), а не лише пробіли:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Дужки тут не потрібні, оскільки результат виглядає наступним чином:

cisco.com
Вихід

Чи можете ви вгадати результат фрагмента нижче? Добре подумайте. Запустіть код і перевірте свої передбачення.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Здивовано? Початкові символи, пробіли на початку. Знову ж таки, експериментуйте на власних прикладах.
2.3.14 Метод replace().
Двопараметричний​ замінити()метод повертає копію оригінального рядка, у якій усі випадки першого аргументу замінено другим аргументом .

Перегляньте приклад коду в редакторі. Запустіть його.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
www.pythoninstitute.org
Thare are it!
Apple 

Приклад виводить:

www.pythoninstitute.org
Thare are it!
Apple
Вихід
Якщо другий аргумент є порожнім рядком, заміна фактично означає видалення рядка першого аргументу. Яка магія відбувається, якщо перший аргумент є порожнім рядком?


Трипараметричний​ замінити()variant використовує третій аргумент (число), щоб обмежити кількість замін .

Подивіться на змінений приклад коду нижче:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Чи можете ви вгадати його результат? Запустіть код і перевірте свої припущення.
2.3.15 Метод rfind().
Одно-, дво- та трипараметричні версіїrfind()Метод виконує майже те ж саме, що й його відповідники (позбавлені префікса r ), але починають пошук із кінця рядка , а не з початку (звідси префікс r для права ).

Подивіться на приклад коду в редакторі та спробуйте передбачити його результат. Запустіть код, щоб перевірити, чи ви мали рацію.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

2.3.16 Метод rstrip().
Два варіантиrstrip()метод роблять майже те саме, щоlstrips, але впливають на протилежну сторону рядка .

Подивіться на приклад коду в редакторі. Чи можете ви вгадати його результат? Запустіть код, щоб перевірити свої припущення.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Як завжди, ми заохочуємо вас експериментувати на власних прикладах.
2.3.18 Метод startswith().
Theпочинається з()Метод є дзеркальним відображеннямendswith()– він перевіряє, чи даний рядок починається з указаного підрядка .

Подивіться приклад у редакторі:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Ось результат цього:

False
True
Вихід
2.3.19 Метод strip().
Theсмуга ()Метод поєднує в собі ефекти, викликаніrstrip()іlstrip()– це створює новий рядок без усіх пробілів на початку та в кінці .

Подивіться на другий приклад у редакторі:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Це результат, який він повертає:

[aleph]
Вихід
Тепер проведіть власні експерименти з двома методами.
2.3.20 Метод swapcase().
Theswapcase()метод створює новий рядок, змінюючи регістри всіх літер у вихідному рядку : символи нижнього регістру стають великими, і навпаки.

Усі інші персонажі залишаються недоторканими.

Подивіться на перший приклад у редакторі:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Чи можете ви вгадати результат? Це не буде добре виглядати, але ви повинні це побачити:

i KNOW THAT i KNOW NOTHING.

2.3.21 Метод title().
Theназва()Метод виконує дещо подібну функцію – він змінює першу літеру кожного слова на прописну, а всі інші перетворює на малі .

Подивіться приклад у редакторі:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

Чи можете ви вгадати його результат? Ось результат:

I Know That I Know Nothing. Part 1.
2.3.22 Метод upper().
І останнє, але не менш важливеверхній()робить копію вихідного рядка, замінює всі літери нижнього регістру на відповідники у верхньому регістрі та повертає рядок як результат.

Подивіться приклад у редакторі:

play_arrow
синхронізація
завантажити
light_mode
темний_режим



Консоль 
термінал
синхронізація

Він виводить:

I KNOW THAT I KNOW NOTHING. PART 2.
Вихід


Ура! Ми дійшли до кінця цього розділу. Ви здивовані будь-яким із методів рядків, які ми обговорювали досі? Виділіть пару хвилин, щоб переглянути їх, і давайте перейдемо до наступної частини курсу, де ми покажемо вам, які чудові речі ми можемо робити з рядками.
2.3.23 SECTION SUMMARY
1. Some of the methods offered by strings are:

capitalize() – changes all string letters to capitals;
center() – centers the string inside the field of a known length;
count() – counts the occurrences of a given character;
join() – joins all items of a tuple/list into one string;
lower() – converts all the string's letters into lower-case letters;
lstrip() – removes the white characters from the beginning of the string;
replace() – replaces a given substring with another;
rfind() – finds a substring starting from the end of the string;
rstrip() – removes the trailing white spaces from the end of the string;
split() – splits the string into a substring using a given delimiter;
strip() – removes the leading and trailing white spaces;
swapcase() – swaps the letters' cases (lower to upper and vice versa)
title() – makes the first letter in each word upper-case;
upper() – converts all the string's letter into upper-case letters.

2. String content can be determined using the following methods (all of them return Boolean values):

endswith() – does the string end with a given substring?
isalnum() – does the string consist only of letters and digits?
isalpha() – does the string consist only of letters?
islower() – does the string consists only of lower-case letters?
isspace() – does the string consists only of white spaces?
isupper() – does the string consists only of upper-case letters?
startswith() – does the string begin with a given substring?

1. Деякі з методів, пропонованих рядками:

капіталізувати()– змінює всі літери рядка на великі;
центр()– центрує рядок всередині поля відомої довжини;
рахувати()– підраховує випадки появи заданого символу;
приєднатися()– об’єднує всі елементи кортежу/списку в один рядок;
нижчий()– перетворює всі літери рядка в малі літери;
lstrip()– видаляє білі символи з початку рядка;
замінити()– замінює заданий підрядок іншим;
rfind()– знаходить підрядок, починаючи з кінця рядка;
rstrip()– видаляє кінцеві пробіли з кінця рядка;
split()– розбиває рядок на підрядок за допомогою заданого розділювача;
смуга ()– видаляє пробіли на початку та в кінці;
swapcase()– змінює регістр літер (нижній на верхній і навпаки)
назва()– першу літеру в кожному слові робить великою;
верхній()– перетворює всі літери рядка у великі літери.

2. Вміст рядка можна визначити за допомогою таких методів (усі вони повертають логічні значення):

endswith()– рядок закінчується заданим підрядком?
isalnum()– рядок складається лише з букв і цифр?
isalpha()– рядок складається лише з букв?
islower()– рядок складається лише з малих літер?
isspace()– рядок складається лише з пробілів?
isupper()– рядок складається лише з великих літер?
починається з()– чи починається рядок із заданого підрядка?



