4.2.1 Параметризовані функції
Повна потужність функції розкривається, коли її можна оснастити інтерфейсом, здатним приймати дані, надані ініціатором. Такі дані можуть змінювати поведінку функції, роблячи її більш гнучкою та адаптованою до мінливих умов.

Параметр насправді є змінною, але є два важливі фактори, які роблять параметри різними та особливими:

параметри існують лише всередині функцій, у яких вони були визначені , і єдине місце, де параметр можна визначити, це пробіл між парою дужок узахзаява;
присвоєння значення параметру виконується під час виклику функції шляхом вказівки відповідного аргументу.
def function(parameter):
    ###
 
Не забувайте:

параметри живуть усередині функцій (це їх природне середовище)
аргументи існують поза функціями та є носіями значень, що передаються відповідним параметрам.
Між цими двома світами існує чітка і однозначна межа.

Давайте збагатимо наведену вище функцію лише одним параметром – ми будемо використовувати його, щоб показати користувачеві номер значення, яке запитує функція.

Ми повинні відновитизахзаява ‒ ось так вона виглядає зараз:

def message(number):
    ###
 
Визначення вказує, що наша функція працює лише з одним параметромномер. Ви можете використовувати її як звичайну змінну, але тільки всередині функції – її більше ніде не видно.

Давайте тепер покращимо тіло функції:


def message(number):
    print("Enter a number:", number)
 
Ми використали параметр. Примітка: ми не присвоїли параметру жодного значення. Це правильно?

Так.

Значення для параметра надійде з середовища функції.

Пам'ятайте: вказівка ​​одного або кількох параметрів у визначенні функції також є обов'язковою, і ви повинні виконати її під час виклику. Ви повинні надати стільки аргументів, скільки визначено параметрів .

Якщо цього не зробити, виникне помилка.

Спробуйте запустити код у редакторі.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Ось що ви побачите на консолі:

TypeError: message() missing 1 required positional argument: 'number'
Вихід
Це виглядає краще, напевно:


def message(number):
    print("Enter a number:", number)
 
message(1)
 
Крім того, він краще поводиться. Код видасть такий результат:

Enter a number: 1
Вихід
Ви бачите, як це працює? Значення аргументу, що використовується під час виклику (1) було передано у функцію, встановлюючи початкове значення названого параметраномер.

Ми повинні зробити вас чутливими до однієї важливої ​​обставини.

Це законно та можливо мати змінну з таким же іменем, як і параметр функції .

Фрагмент ілюструє це явище:


def message(number):
    print("Enter a number:", number)
 
number = 1234
message(1)
print(number)
 
Подібна ситуація активує механізм, який називається затіненням :

параметрxзатінює будь-яку змінну з таким же ім'ям, але...
... тільки всередині функції, що визначає параметр.
Названий параметрномерє абсолютно відмінною сутністю від названої змінноїномер.

Це означає, що наведений вище фрагмент дасть такий результат:

Enter a number: 1
1234
Вихід

Функція може мати скільки завгодно параметрів , але чим більше у вас параметрів, тим важче запам’ятати їх ролі та призначення.

Давайте модифікуємо функцію – тепер вона має два параметри :

def message(what, number):
    print("Enter", what, "number", number)
 
Це також означає, що для виклику функції знадобляться два аргументи .

Перший новий параметр призначений для назви потрібного значення.

Ось:


def message(what, number):
    print("Enter", what, "number", number)
 
message("telephone", 11)
message("price", 5)
message("number", "number")
 
Це результат, який ви збираєтеся побачити:

Enter telephone number 11
Enter price number 5
Enter number number number
Вихід
Запустіть код, змініть його, додайте більше параметрів і подивіться, як це вплине на результат.

4.2.2 Передача позиційних параметрів
Техніка, яка призначає i- й (перший, другий і так далі) аргумент i- му (першому, другому і так далі) параметру функції, називається позиційною передачею параметрів , тоді як аргументи, передані таким чином, називаються позиційними аргументами .

Ви вже використовували його, але Python може запропонувати набагато більше. Зараз ми вам про це розповімо.


def my_function(a, b, c):
    print(a, b, c)
 
my_function(1, 2, 3)
 
Примітка: передача позиційних параметрів інтуїтивно використовується людьми в багатьох соціальних випадках. Наприклад, може бути загальноприйнятим, що коли ми представляємося, ми згадуємо своє ім’я (імена) перед своїм прізвищем, наприклад, «Мене звати Джон Доу».

До речі, угорці роблять це у зворотному порядку.

Давайте запровадимо цю соціальну звичку в Python. Наступна функція відповідатиме за представлення когось:


def introduction(first_name, last_name):
    print("Hello, my name is", first_name, last_name)
 
introduction("Luke", "Skywalker")
introduction("Jesse", "Quick")
introduction("Clark", "Kent")
 
Чи можете ви вгадати результат? Запустіть код і дізнайтеся, чи ви праві.

А тепер уявіть, що така ж функція використовується в Угорщині. У цьому випадку код виглядатиме так:


def introduction(first_name, last_name):
    print("Hello, my name is", first_name, last_name)
 
introduction("Skywalker", "Luke")
introduction("Quick", "Jesse")
introduction("Kent", "Clark")
 
Вихід буде виглядати інакше. Ви можете вгадати це?

Запустіть код, щоб перевірити, чи ви також маєте рацію. Ви здивовані?

Чи можете ви зробити функцію більш незалежною від культури?
def introduction(first_name, last_name):
    print("Hello, my name is", first_name, last_name)
 
introduction(first_name = "James", last_name = "Bond")
introduction(last_name = "Skywalker", first_name = "Luke")
 Концепція зрозуміла – перед значеннями, що передаються параметрам, ідуть імена цільових параметрів, після яких іде=знак.

Позиція тут не має значення – значення кожного аргументу знає своє призначення на основі використаного імені.

Ви повинні мати можливість передбачити результат. Запустіть код, щоб перевірити, чи ви праві.

Звичайно, ви не повинні використовувати неіснуючу назву параметра .

Наступний фрагмент спричинить помилку виконання:


def introduction(first_name, last_name):
    print("Hello, my name is", first_name, last_name)
 
introduction(surname="Skywalker", first_name="Luke")
 
Ось що вам скаже Python:

TypeError: introduction() got an unexpected keyword argument 'surname'
Вихід
Спробуйте самі.

4.2.4 Поєднання позиційних і ключових аргументів
Ви можете змішувати обидва стилі, якщо хочете – існує лише одне непорушне правило: ви повинні поставити позиційні аргументи перед ключовими аргументами .

Якщо ви подумаєте на мить, то обов’язково здогадаєтесь чому.

Щоб показати вам, як це працює, ми використаємо таку просту функцію з трьома параметрами:


def adding(a, b, c):
    print(a, "+", b, "+", c, "=", a + b + c)
 
Його мета — оцінити та представити суму всіх своїх аргументів.

Функція, викликана таким чином:


adding(1, 2, 3)
 
виведе:

1 + 2 + 3 = 6
Вихід
Це був ‒ як ви можете підозрювати ‒ чистий приклад проходження позиційних аргументів .

Звичайно, ви можете замінити такий виклик варіантом із суто ключовим словом, наприклад:


adding(c = 1, a = 2, b = 3)
 
Наша програма виведе такий рядок:

2 + 3 + 1 = 6
Вихід
Зверніть увагу на порядок значень.

Давайте зараз спробуємо змішати обидва стилі.

Подивіться на виклик функції нижче:


adding(3, c = 1, b = 2)
 
Давайте розберемо його:

аргумент (3) дляaпараметр передається позиційним способом;
аргументи завіbвказуються як ключові.
Ось що ви побачите на консолі:

3 + 2 + 1 = 6
Вихід
Будьте уважні, остерігайтеся помилок. Якщо ви спробуєте передати більше одного значення одному аргументу, ви отримаєте лише помилку виконання.

Подивіться на виклик нижче - здається, що ми намагалися встановитиaдвічі:


adding(3, a = 1, b = 2)
 
Відповідь Python:

TypeError: adding() got multiple values for argument 'a'
Вихід
Подивіться на фрагмент нижче. Такий код є цілком правильним, але він не має особливого сенсу:


adding(4, 3, c = 2)
 
Все правильно, але залишити лише один аргумент ключового слова виглядає трохи дивно ‒ як ви думаєте?

4.2.5 Параметризовані функції – докладніше
Буває так, що значення певного параметра використовуються частіше за інші. Такі аргументи можуть мати значення за замовчуванням (попередньо визначені), якщо їх відповідні аргументи були пропущені.

Кажуть, найпопулярніше англійське прізвище Сміт . Спробуємо це врахувати.

Значення параметра за замовчуванням встановлюється з використанням чіткого та наочного синтаксису:


def introduction(first_name, last_name="Smith"):
     print("Hello, my name is", first_name, last_name)
 
Вам потрібно лише розширити назву параметра за допомогою=знак, а потім значення за замовчуванням.

Давайте викличемо функцію як зазвичай:


introduction("James", "Doe")
 
Чи можете ви вгадати результат програми? Запустіть і перевірте, чи ви праві.

і? Все виглядає так само, але коли ви викликаєте функцію таким чином, який на перший погляд виглядає трохи підозрілим, наприклад:


introduction("Henry")
 
або це:


introduction(first_name="William")
 
помилки не буде, обидва виклики завершаться успішно, а консоль покаже наступний вихід:

Hello, my name is Henry Smith
Hello, my name is William Smith
Вихід
Перевірте це.

Ви можете піти далі, якщо це корисно. Обидва параметри тепер мають значення за замовчуванням, подивіться на код нижче:


def introduction(first_name="John", last_name="Smith"):
    print("Hello, my name is", first_name, last_name)
 
Це робить наступний виклик абсолютно дійсним:


introduction()
 
І це очікуваний результат:

Hello, my name is John Smith
Вихід
Якщо ви використовуєте один аргумент ключового слова, решта матиме значення за замовчуванням:


introduction(last_name="Hopkins")
 
Результат:

Hello, my name is John Hopkins
Вихід
Перевірте це.

Вітаємо! Ви щойно навчилися деяким основним прийомам спілкування з функціями.

4.2.6 РЕЗЮМЕ РОЗДІЛУ
1. Ви можете передавати інформацію функціям за допомогою параметрів. Ваші функції можуть мати скільки завгодно параметрів.

Приклад функції з одним параметром:


def hi(name):
    print("Hi,", name)
 
hi("Greg")
 
Приклад функції з двома параметрами:


def hi_all(name_1, name_2):
    print("Hi,", name_2)
    print("Hi,", name_1)
 
hi_all("Sebastian", "Konrad")
 
Приклад функції з трьома параметрами:


def address(street, city, postal_code):
    print("Your address is:", street, "St.,", city, postal_code)
 
s = input("Street: ")
p_c = input("Postal Code: ")
c = input("City: ")
address(s, c, p_c)
 
2. Ви можете передати аргументи функції за допомогою таких прийомів:

позиційна передача аргументів , у якій порядок передачі аргументів має значення (Приклад 1)
ключове слово (іменований) передача аргументів , у якій порядок переданих аргументів не має значення (Приклад 2)
поєднання позиційної передачі аргументів і ключових слів (Приклад 3.)

Ex. 1
def subtra(a, b):
    print(a - b)
 
subtra(5, 2) # outputs: 3
subtra(2, 5) # outputs: -3
 
 
Ex. 2
def subtra(a, b):
    print(a - b)
 
subtra(a=5, b=2) # outputs: 3
subtra(b=2, a=5) # outputs: 3
 
Ex. 3
def subtra(a, b):
    print(a - b)
 
subtra(5, b=2) # outputs: 3
subtra(5, 2) # outputs: 3
 
Важливо пам’ятати, що позиційні аргументи не повинні слідувати за аргументами ключового слова . Ось чому, якщо ви спробуєте запустити наступний фрагмент:


def subtra(a, b):
    print(a - b)
 
subtra(5, b=2) # outputs: 3
subtra(a=5, 2) # Syntax Error
 
Python не дозволить вам це зробити, сигналізуючи aСинтаксична помилка.

3. Ви можете використовувати техніку передачі аргументів ключового слова, щоб попередньо визначити значення для даного аргументу:


def name(first_name, last_name="Smith"):
    print(first_name, last_name)
 
name("Andy") # outputs: Andy Smith
name("Betty", "Johnson") # outputs: Betty Johnson (the keyword argument replaced by "Johnson")
 


4.3. Розділ 3 – Повернення результату з функції
Ласкаво просимо до розділу 3! У цій частині курсу ви дізнаєтесь про ефекти та результати функцій, вираз повернення та значення None . Ви також дізнаєтеся, як передавати списки як аргументи функції, як повертати списки як результати функції та як призначати результати функції змінним. Ходімо!

4.3.1 Наслідки та результати: інструкція про повернення
Всі представлені раніше функції мають певний ефект – видають якийсь текст і відправляють його на консоль.

Звичайно, функції, як і їхні математичні побратими, можуть мати результати.

Щоб змусити функції повертати значення (але не тільки для цієї мети), ви використовуєтеповерненняінструкція.

Це слово дає вам повне уявлення про його можливості. Примітка: це ключове слово Python .

Theповерненняінструкція має два різних варіанти – розглянемо їх окремо.

повернутися без виразу
Розглянемо таку функцію:


def happy_new_year(wishes = True):
    print("Three...")
    print("Two...")
    print("One...")
    if not wishes:
        return
 
    print("Happy New Year!")
 
При виклику без жодних аргументів:


happy_new_year()
 
функція створює невеликий шум – результат виглядатиме так:

Three...
Two...
One...
Happy New Year!
Вихід
Забезпеченняпомилковийяк аргумент:


happy_new_year(False)
 
змінить поведінку функції ‒ theповерненняінструкція спричинить його завершення безпосередньо перед бажаннями ‒ це оновлений вихід:

Three...
Two...
One...
Вихід
повернутися з виразом
Другийповерненняваріант розширено виразом :


def function():
    return expression
 
Є два наслідки його використання:

викликає негайне припинення виконання функції (нічого нового порівняно з першим варіантом)
крім того, функція обчислить значення виразу та поверне його (звідси знову така назва) як результат функції .
Так, ми вже знаємо – цей приклад не дуже складний:


def boring_function():
    return 123
 
x = boring_function()
 
print("The boring_function has returned its result. It's:", x)
 
Фрагмент записує такий текст на консоль:

The boring_function has returned its result. It's: 123
Вихід
Давайте дослідимо це на деякий час.

Проаналізуйте малюнок нижче:
![img.png](img.png)
Theповерненняінструкція, збагачена виразом (тут вираз дуже простий), «переносить» значення виразу до місця, де була викликана функція.

Результат можна вільно використовувати тут, наприклад, для призначення змінній.

Його також можна повністю проігнорувати та втратити безслідно.

Зауважте, ми не надто ввічливі – функція повертає значення, а ми його ігноруємо (не використовуємо жодним чином):


def boring_function():
    print("'Boredom Mode' ON.")
    return 123
 
print("This lesson is interesting!")
boring_function()
print("This lesson is boring...")
Програма видає такі результати:

This lesson is interesting!
'Boredom Mode' ON.
This lesson is boring...
Вихід
Це карається? Зовсім ні.

Єдиний недолік – безповоротно втрачений результат.

Не забувайте:

вам завжди дозволено ігнорувати результат функції та бути задоволеним ефектом функції (якщо функція має такий)
якщо функція призначена для повернення корисного результату, вона повинна містити другий варіантповерненняінструкція.
Хвилинку – це означає, що є й марні результати? Так, в якомусь сенсі.

4.3.2 Кілька слів про None
Дозвольте познайомити вас із дуже цікавим значенням (чесно кажучи, жодним значенням) під назвоюЖодного.

Його дані не представляють жодної розумної цінності – насправді, це взагалі не цінність; отже, він не повинен брати участь у жодних виразах .

Наприклад, такий фрагмент:


print(None + 2)
 
спричинить помилку виконання, описану таким діагностичним повідомленням:

TypeError: unsupported operand type(s) for +: 'NoneType' and 'int'
Вихід
Примітка:Жодногоє ключовим словом .

Є лише два види обставин, колиЖодногоможна безпечно використовувати:

коли ви призначаєте його змінній (або повертаєте як результат функції )
коли ви порівнюєте його зі змінною, щоб діагностувати його внутрішній стан.
Так само як тут:


value = None
if value is None:
    print("Sorry, you don't carry any value")
 
Не забувайте про це: якщо функція не повертає певне значення за допомогою aповерненняречення виразу, передбачається, що воно неявно повертаєЖодного.

Давайте перевіримо це.

Подивіться на код у редакторі.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Очевидно, щодивна_функціяфункція повертаєправдаколи його аргумент парний.

Що повертає інакше?

Ми можемо використати такий код, щоб перевірити це:


print(strange_function(2))
print(strange_function(1))
 
Ось що ми бачимо в консолі:

True
None
Вихід
Не дивуйтеся наступного разу, коли побачитеЖодногояк результат функції – це може бути ознакою тонкої помилки всередині функції.

