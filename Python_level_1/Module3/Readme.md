
3.1. Section 1 – Making decisions in Python
Ласкаво просимо до третього модуля! У першому розділі ми дізнаємося про умовні оператори та як їх використовувати для прийняття рішень у Python.
3.1.1 Запитання та відповіді

Програміст пише програму, а програма задає запитання .

Комп'ютер виконує програму і дає відповіді . Програма повинна вміти реагувати відповідно до отриманих відповідей .

На щастя, комп’ютери знають лише два типи відповідей:

так, це правда;
ні, це неправда.
Ви ніколи не отримаєте відповідь на кшталт « Дайте мені подумати....» , «Я не знаю » або «Напевно так», але я не знаю напевно» .

Щоб ставити запитання, Python використовує набір дуже спеціальних операторів . Давайте переглянемо їх один за одним, проілюструвавши їх вплив на кількох простих прикладах.
3.1.2 Порівняння: оператор рівності
Запитання: чи рівні дві величини ?

Щоб поставити це запитання, ви використовуєте==(рівно рівно) оператор.

Не забувайте про цю важливу відмінність:

=є оператором присвоювання , наприклад, a = bприсвоює aзі значенням b;
==питання, чи рівні ці значення? тому a == b порівнює a і b.
Це бінарний оператор із лівостороннім зв’язуванням . Він потребує двох аргументів і перевіряє, чи вони рівні .
Лівостороннє та Правостороннє Зв'язування
Лівостороннє зв'язування (Left-Associative) означає, що операції виконуються зліва направо. Якщо кілька операторів з однаковим пріоритетом знаходяться поруч, вони обробляються зліва направо.

Правостороннє зв'язування (Right-Associative) означає, що операції виконуються справа наліво. Оператори з однаковим пріоритетом обробляються справа наліво.

Приклади Лівостороннього Зв'язування
Більшість операторів у Python мають лівостороннє зв'язування. Розглянемо приклад з оператором додавання:

python
Копіювати код
5 - 3 + 2
Тут операції будуть виконуватись зліва направо:

Спочатку виконується 5 - 3, результатом буде 2.
Потім виконується 2 + 2, результатом буде 4.
Тобто, вираз 5 - 3 + 2 інтерпретується як (5 - 3) + 2.

Приклади Правостороннього Зв'язування
Деякі оператори, такі як оператор присвоєння та оператор піднесення до степеня, мають правостороннє зв'язування. Розглянемо приклад з оператором піднесення до степеня:

python
Копіювати код
2 ** 3 ** 2
Тут операції будуть виконуватись справа наліво:

Спочатку виконується 3 ** 2, результатом буде 9.
Потім виконується 2 ** 9, результатом буде 512.
Тобто, вираз 2 ** 3 ** 2 інтерпретується як 2 ** (3 ** 2).

Лівостороннє Зв'язування в Операторах Присвоєння
Розглянемо приклад з операторами присвоєння:

python
Копіювати код
a = b = c = 1
Тут операції виконуються справа наліво:

Спочатку виконується c = 1.
Потім виконується b = c, де c вже має значення 1.
Нарешті, виконується a = b, де b вже має значення 1.
Таблиця Пріоритетів Операторів у Python
Для кращого розуміння, наведемо спрощену таблицю пріоритетів операторів у Python з урахуванням зв'язування:
![img.png](img.png)
Оператор	Опис	Пріоритет	Зв'язування
**	Піднесення до степеня	Високий	Правостороннє
*, /, //, %	Множення, ділення, модуль	Середній	Лівостороннє
+, -	Додавання, віднімання	Середній	Лівостороннє
<<, >>	Зсув	Середній	Лівостороннє
<, <=, >, >=	Порівняння	Низький	Лівостороннє
==, !=	Рівність, нерівність	Низький	Лівостороннє
=	Присвоєння	Низький	Правостороннє
+=, -=, *=, /=, **=	Присвоєння з операцією	Низький	Правостороннє
Висновок
Лівостороннє зв'язування означає, що операції виконуються зліва направо. Приклад: 5 - 3 + 2.
Правостороннє зв'язування означає, що операції виконуються справа наліво. Приклад: 2 ** 3 ** 2.
Знання про зв'язування операторів є важливим для розуміння та правильного використання виразів у Python, особливо коли вирази стають складними.

3.1.3 Вправи
А тепер задамо кілька запитань. Спробуйте вгадати відповіді.

Питання №1 : Який результат наступного порівняння?

2 == 2

Перевірте
Правда- звичайно, 2 дорівнює 2. Python відповістьПравда(запам'ятайте цю пару попередньо визначених літералів,Правдаіпомилковий- це також ключові слова Python).


Запитання №2 : Який результат наступного порівняння?

2 == 2.

Перевірте
Це питання не таке просте, як перше. На щастя, Python може перетворити ціле число в його дійсний еквівалент, і, отже, відповідь така:Правда.

Запитання №3 : Який результат наступного порівняння?

1 == 2

Перевірте
Це повинно бути легко. Відповідь буде (вірніше, завжди)помилковий.

3.1.4 Оператори
Рівність: оператор дорівнює ( == )
The==Оператор (дорівнює) порівнює значення двох операндів. Якщо вони рівні, результат порівняння єПравда. Якщо вони не рівні, результат порівняння єпомилковий.

Подивіться на порівняння рівності нижче – який результат цієї операції?


var == 0
 
Зауважте, що ми не можемо знайти відповідь, якщо не знаємо, яке значення наразі зберігається у зміннійвар.

Якщо змінна змінювалася багато разів під час виконання вашої програми або її початкове значення вводиться з консолі, відповідь на це питання може дати тільки Python і тільки під час виконання.

А тепер уявіть програміста, який страждає від безсоння, і йому доводиться окремо рахувати чорних і білих овець, якщо чорних овець рівно вдвічі більше, ніж білих.

Питання буде наступним:


black_sheep == 2 * white_sheep
 
Через низький пріоритет==оператор, питання розглядається як еквівалентне цьому:


black_sheep == (2 * white_sheep)
 
Отже, давайте попрактикуємося у вашому розумінні==оператор зараз – чи можете ви вгадати результат коду нижче?

play_arrow
sync
download
light_mode
dark_mode



Console 
terminal
sync
True
False
Запустіть код і перевірте, чи ви маєте рацію.

Нерівність: оператор не дорівнює ( != )
The!=Оператор (не дорівнює) також порівнює значення двох операндів. Ось різниця: якщо вони рівні, результат порівняння єПомилковий. Якщо вони не рівні, результат порівняння єПравда.

Тепер подивіться на порівняння нерівностей нижче – чи можете ви вгадати результат цієї операції?


var = 0  # Assigning 0 to var
print(var != 0)
 
var = 1  # Assigning 1 to var
print(var != 0)
 
Запустіть код і перевірте, чи ви маєте рацію.

Оператори порівняння: більше
Ви також можете задати порівняльне запитання за допомогою>(більше ніж) оператор.

Якщо ви хочете дізнатися, чи чорних овець більше, ніж білих, ви можете написати це так:


black_sheep > white_sheep  # Greater than
 
Правдапідтверджує це;помилковийзаперечує це.

Оператори порівняння: більше або дорівнює
Оператор більше має ще один спеціальний, нестрогий варіант, але він позначається інакше, ніж у класичній арифметичній нотації:>=(більше або дорівнює).

Є дві наступні ознаки, а не одна.

Обидва ці оператори (суворий і нестрогий), а також два інших, розглянуті в наступному розділі, є двійковими операторами з лівостороннім прив’язуванням , і їхній пріоритет більший, ніж показаний==і!=.

Якщо ми хочемо дізнатися, чи потрібно нам носити теплу шапку, ми задаємося наступним питанням:


centigrade_outside >= 0.0  # Greater than or equal to
 
Оператори порівняння: менше/менше або дорівнює
Як ви, напевно, вже здогадалися, у цьому випадку використовуються такі оператори: the<(менше) оператор і його нестрогий брат:<=(менше або дорівнює).

Подивіться на цей простий приклад:


current_velocity_mph < 85  # Less than
current_velocity_mph <= 85  # Less than or equal to
 
Перевіримо, чи є ризик бути оштрафованим ДАІ (перше питання суворе, друге – ні).


3.1.5 Використання відповідей
Що можна зробити з відповіддю (тобто результатом операції порівняння), отриманою з комп’ютера?

Є принаймні дві можливості: по-перше, ви можете запам’ятати його ( зберегти в змінній ) і використати пізніше. Як ти це робиш? Ну, ви використовуєте довільну змінну так:


answer = number_of_lions >= number_of_lionesses
 
Вміст змінної підкаже відповідь на поставлене запитання.

Другий варіант більш зручний і набагато поширеніший: ви можете використовувати отриману відповідь, щоб прийняти рішення про майбутнє програми .

Для цього потрібна спеціальна інструкція, і ми її обговоримо найближчим часом.

Тепер нам потрібно оновити нашу таблицю пріоритетів і додати в неї всі нові оператори. Тепер це виглядає так:

![img_1.png](img_1.png)

3.1.7 Умови та умовне виконання
Ви вже знаєте, як задавати питання Python, але все ще не знаєте, як розумно використовувати відповіді. Ви повинні мати механізм, який дозволить вам щось робити, якщо умова виконується, і не робити цього, якщо вона не виконана .

Це так само, як у реальному житті: ви робите певні речі або ні, коли певна умова виконується чи ні, наприклад, ви йдете гуляти, якщо погода гарна, або залишаєтеся вдома, якщо сиро й холодно.

Для прийняття таких рішень Python пропонує спеціальну інструкцію. Через свою природу та застосування її називають умовною інструкцією (або умовним оператором).

Існує кілька його варіантів. Ми почнемо з найпростішого, поступово збільшуючи складність.

Перша форма умовного висловлення, яку ви можете побачити нижче, написана дуже неформально, але образно:

if true_or_not:
    do_this_if_true
 
Цей умовний оператор складається з наступних, суворо необхідних, елементів лише в такому порядку:

вякщоключове слово;
один або кілька пробілів;
вираз (запитання чи відповідь), значення якого буде інтерпретовано виключно в термінахправда(коли його значення відмінне від нуля) іпомилковий(коли він дорівнює нулю);
двокрапка , після якої йде новий рядок;
інструкція з відступом або набір інструкцій (принаймні одна інструкція є обов’язковою); відступ може бути досягнутий двома способами – вставленням певної кількості пробілів (рекомендовано використовувати чотири пробіли відступу ) або за допомогою символу табуляції ; примітка: якщо в частині з відступом більше однієї вказівки, відступ повинен бути однаковим у всіх рядках; незважаючи на те, що це може виглядати однаково, якщо ви використовуєте табуляції з пробілами, важливо зробити всі відступи абсолютно однаковими – Python 3 не дозволяє змішувати пробіли та табуляції для відступів.
Як це твердження працює?

Якщоправда_чи_нівираз представляє істину (тобто його значення не дорівнює нулю), оператор(и) з відступом буде виконано ;
якщоправда_чи_нівираз не представляє істини (тобто його значення дорівнює нулю), оператор(и) з відступом буде пропущено (ігноровано), а наступна виконана інструкція буде тією, що буде наступною за початковим рівнем відступу.

У реальному житті ми часто висловлюємо бажання:

якщо буде гарна погода, підемо гуляти

тоді будемо обідати


Як бачите, обід не є умовним заняттям і не залежить від погоди.

Знаючи, які умови впливають на нашу поведінку, і припускаючи, що у нас є функції без параметріввийти на прогулянку()іобідати(), ми можемо написати такий фрагмент:


if the_weather_is_good:
    go_for_a_walk()
have_lunch()
 
Умовне виконання: оператор if
Якщо певний безсонний розробник Python засинає, коли він або вона нараховує 120 овець, то процедура викликання сну може бути реалізована як спеціальна функція під назвоюсон_і_мрія(), весь код має таку форму:


if sheep_counter >= 120: # Evaluate a test expression
    sleep_and_dream() # Execute if test expression is True
 
Ви можете прочитати це як: якщоsheep_counterбільше або дорівнює120, потім заснути і мріяти (тобто виконуватисон_і_мріяфункція.)

Ми вже говорили, що оператори, що виконуються умовно, мають мати відступ . Це створює дуже розбірливу структуру, яка чітко демонструє всі можливі шляхи виконання в коді.

Подивіться на наступний код:


if sheep_counter >= 120:
    make_a_bed()
    take_a_shower()
    sleep_and_dream()
feed_the_sheepdogs()
 
Як бачите, стелити ліжко, приймати душ, засинати і мріяти все виконується умовно – колиsheep_counterдосягає бажаної межі.

Однак годування вівчарок проводиться завжди (тобтоfeed_the_sheepdogs()функція не має відступу і не належить доякщоблок, що означає, що він завжди виконується.)

Тепер ми обговоримо інший варіант умовного оператора, який також дозволяє виконувати додаткову дію, коли умова не виконується.

Умовне виконання: оператор if-else
Ми почали з простої фрази: « Якщо буде хороша погода, ми підемо гуляти» .

Примітка: немає жодного слова про те, що буде, якщо погода погана. Знаємо лише, що на вулицю виходити не будемо, а чим би могли зайнятися, невідомо. Можливо, ми також захочемо щось спланувати на випадок поганої погоди.

Ми можемо сказати, наприклад: якщо хороша погода, ми підемо гуляти, інакше ми підемо в театр .

Тепер ми знаємо, що ми будемо робити, якщо умови будуть виконані , і ми знаємо, що ми будемо робити, якщо не все піде як слід . Іншими словами, у нас є «план Б».

Python дозволяє нам виражати такі альтернативні плани. Це робиться за допомогою другої, трохи складнішої форми умовного оператора, оператора if-else :


if true_or_false_condition:
    perform_if_condition_true
else:
    perform_if_condition_false
 
Таким чином, є нове слово:інше– це ключове слово .

Частина коду, яка починається зіншеговорить, що робити, якщо умова, зазначена дляякщоне зустрічається (зверніть увагу на двокрапку після слова).

Виконання if-else виглядає наступним чином:

якщо умова має значення True (її значення не дорівнює нулю), товиконати_якщо_умова_істинаоператор виконується, а умовний оператор закінчується;
якщо умова має значення False (вона дорівнює нулю), товиконати_якщо_умова_хибнаоператор виконується, і умовний оператор закінчується.
Інструкція if-else : більш умовне виконання
Використовуючи цю форму умовного твердження, ми можемо описати наші плани наступним чином:


if the_weather_is_good:
    go_for_a_walk()
else:
    go_to_a_theater()
have_lunch()
 
Якщо буде гарна погода, підемо гуляти. Інакше ми підемо в театр. Незалежно від того, хороша чи погана погода, ми обідаємо потім (після прогулянки або після походу в театр).

Усе, що ми сказали про відступи , працює так само всередині гілки else :


if the_weather_is_good:
    go_for_a_walk()
    have_fun()
else:
    go_to_a_theater()
    enjoy_the_movie()
have_lunch()
 
Вкладені оператори if-else
Тепер давайте обговоримо два особливих випадки умовного оператора.

Спочатку розглянемо випадок, коли вказівка ​​розміщена післяякщоє іншимякщо.

Читайте, що ми запланували на цю неділю. Якщо буде гарна погода, підемо гуляти. Якщо ми знайдемо хороший ресторан, ми там пообідаємо. Інакше з’їмо бутерброд. Якщо погода погана, ми підемо в театр. Якщо квитків немає, підемо за покупками в найближчий торговий центр.

Напишемо те саме на Python. Уважно розгляньте код тут:


if the_weather_is_good:
    if nice_restaurant_is_found:
        have_lunch()
    else:
        eat_a_sandwich()
else:
    if tickets_are_available:
        go_to_the_theater()
    else:
        go_shopping()
Ось два важливі моменти:

це використанняякщооператор відомий як вкладення ; пам'ятайте, що коженіншевідноситься доякщоякий лежить на одному рівні відступу ; вам потрібно це знати, щоб визначити, як поєднуються if і else s;
подумайте про те, як відступ покращує читабельність і робить код легшим для розуміння та відстеження.
Заява elif​
Другий окремий випадок представляє ще одне нове ключове слово Python: elif . Як ви, напевно, підозрюєте, це коротша форма else if .

elifвикористовується для перевірки більш ніж однієї умови та для зупинки , коли знайдено перше твердження, яке є істинним.

Наш наступний приклад нагадує вкладення, але подібності дуже незначні. Знову ж таки, ми змінимо свої плани і висловимо їх так: якщо погода хороша, ми підемо гуляти, інакше, якщо отримаємо квитки, ми підемо в театр, інакше, якщо є вільні столики в ресторан, підемо обідати; якщо нічого не допоможе, ми залишимося вдома і пограємо в шахи.

Ви помітили, скільки разів ми використали слово інакше ? Це етап, на якомуelifключове слово відіграє свою роль.

Давайте напишемо той самий сценарій за допомогою Python:


if the_weather_is_good:
    go_for_a_walk()
elif tickets_are_available:
    go_to_the_theater()
elif table_is_available:
    go_for_lunch()
else:
    play_chess_at_home()
 
Спосіб складання наступних операторів if-elif-else іноді називають каскадом .

Зверніть увагу ще раз, як відступи покращують читабельність коду.

У цьому випадку слід приділити деяку додаткову увагу:

ви не повинні використовуватиіншебез попередньогоякщо;
іншезавжди є останньою гілкою каскаду , незалежно від того, чи використовували виelifчи ні;
іншеє необов'язковою частиною каскаду, і її можна опустити;
якщо єіншегілка в каскаді, виконується тільки одна з усіх гілок;
якщо немаєіншегілка, можливо, жодна з доступних гілок не виконується.
Це може здатися трохи дивним, але, сподіваюся, кілька простих прикладів допоможуть пролити більше світла.

3.1.8 Аналіз зразків коду
Зараз ми покажемо вам кілька простих, але повних програм. Ми не пояснюватимемо їх докладно, оскільки вважаємо коментарі (і назви змінних) усередині коду достатніми посібниками.

Усі програми вирішують одну й ту саму задачу – знаходять найбільше з кількох чисел і виводять його на друк .

приклад 1:

Ми почнемо з найпростішого випадку – як визначити більше з двох чисел :


# Read two numbers
number1 = int(input("Enter the first number: "))
number2 = int(input("Enter the second number: "))
 
# Choose the larger number
if number1 > number2:
    larger_number = number1
else:
    larger_number = number2
 
# Print the result
print("The larger number is:", larger_number)
 
Наведений вище фрагмент має бути зрозумілим – він читає два цілих значення, порівнює їх і знаходить, яке з них більше.

приклад 2:

Зараз ми покажемо вам один цікавий факт. У Python є цікава функція – подивіться на код нижче:


# Read two numbers
number1 = int(input("Enter the first number: "))
number2 = int(input("Enter the second number: "))
 
# Choose the larger number
if number1 > number2: larger_number = number1
else: larger_number = number2
 
# Print the result
print("The larger number is:", larger_number)
 
Примітка: якщо будь-яка з гілок if-elif-else містить лише одну інструкцію, ви можете закодувати її в більш вичерпній формі (вам не потрібно робити відступ після ключового слова, а просто продовжити рядок після двокрапки) .

Однак цей стиль може вводити в оману, і ми не збираємося використовувати його в наших майбутніх програмах, але це точно варто знати, якщо ви хочете читати та розуміти чиїсь програми.

Інших відмінностей в коді немає.

приклад 3:

Настав час ускладнити код – давайте знайдемо найбільше з трьох чисел. Чи збільшить це код? Трохи.

Вважаємо, що перше значення найбільше. Потім ми перевіряємо цю гіпотезу двома значеннями, що залишилися.

Подивіться на код нижче:


# Read three numbers
number1 = int(input("Enter the first number: "))
number2 = int(input("Enter the second number: "))
number3 = int(input("Enter the third number: "))
 
# We temporarily assume that the first number
# is the largest one.
# We will verify this soon.
largest_number = number1
 
# We check if the second number is larger than the current largest_number
# and update the largest_number if needed.
if number2 > largest_number:
    largest_number = number2
 
# We check if the third number is larger than the current largest_number
# and update the largest_number if needed.
if number3 > largest_number:
    largest_number = number3
 
# Print the result
print("The largest number is:", largest_number)
 
Цей метод значно простіший, ніж спроба знайти найбільше число відразу шляхом порівняння всіх можливих пар чисел (тобто перше з другим, друге з третім, третє з першим). Спробуйте перебудувати код для себе.


play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація


3.1.13 РЕЗЮМЕ РОЗДІЛУ
1. Оператори порівняння (інакше відомі як реляційні ) використовуються для порівняння значень. У наведеній нижче таблиці показано, як працюють оператори порівняння, припускаючи, що x = 0, y = 1та z = 0:

2. Якщо ви хочете виконати певний код лише за умови виконання певної умови, ви можете використати умовний оператор :

Одинокийякщозаява, наприклад:

x = 10
 
if x == 10: # condition
    print("x is equal to 10")  # Executed if the condition is True.
 
серіяякщозаяви, наприклад:

x = 10
 
if x > 5: # condition one
    print("x is greater than 5")  # Executed if condition one is True.
 
if x < 10: # condition two
    print("x is less than 10")  # Executed if condition two is True.
 
if x == 10: # condition three
    print("x is equal to 10")  # Executed if condition three is True.
 
    Коженякщотвердження перевіряється окремо.

анякщо-інакшезаява, наприклад:

x = 10
 
if x < 10: # condition
    print("x is less than 10")  # Executed if the condition is True.
 
else:
    print("x is greater than or equal to 10")  # Executed if the condition is False.
 
серіяякщозаяви, за якими йде anінше, наприклад:

x = 10
 
if x > 5: # condition one
    print("x is greater than 5")  # Executed if condition one is True.
 
if x < 10: # condition two
    print("x is less than 10")  # Executed if condition two is True.
 
if x == 10: # condition three
     print("x is equal to 10")  # Executed if condition three is True.
 
    Коженякщотестується окремо. Тілоіншевиконується, якщо останнійякщоєпомилковий.

Theякщо-еліф-іншезаява, наприклад:

x = 10
 
if x == 10: # True
    print("x == 10")
 
if x > 15: # False
    print("x > 15")
 
elif x > 10: # False
    print("x > 10")
 
elif x > 5: # True
    print("x > 5")
 
else:
    print("else will not be executed")
 
    Якщо умова дляякщоєпомилковий, програма перевіряє умови подальшогоelifблоки - першelifблок, тобтоправдавиконується. Якщо всі умови єпомилковий,іншеблок буде виконано.

Вкладені умовні оператори, наприклад:

x = 10
 
if x > 5: # True
    if x == 6: # False
        print("nested: x == 6")
    elif x == 10: # True
        print("nested: x == 10")
    else:
        print("nested: else")
else:
    print("else")
 

![img_2.png](img_2.png)



3.2. Section 2 – Loops in Python

3.2.1 Зациклення вашого коду за допомогою while

Чи згодні ви з поданим нижче твердженням?

while there is something to do
    do it
 
Зауважте, що цей запис також заявляє, що якщо нічого не робити, нічого не станеться.

Загалом, у Python цикл можна представити так:

while
    instruction
 
Якщо ви помітили деякі схожості з інструкцією if , це цілком нормально. Дійсно, синтаксична різниця лише в одному: ви використовуєте словопокизамість словаякщо.

Семантична різниця більш важлива: коли умова виконується, if виконує свої оператори лише один раз ; while повторює виконання до тих пір, поки умова оцінюється якправда.

Примітка: тут також застосовуються всі правила щодо відступів . Незабаром ми вам це покажемо.

Подивіться на алгоритм нижче:

while conditional_expression:
    instruction_one
    instruction_two
    instruction_three
    :
    :
    instruction_n
 
Тепер важливо пам’ятати, що:

якщо ви хочете виконати більше одного оператора в одномупокиloop , ви повинні (як зякщо) однакові відступи для всіх інструкцій;
інструкція або набір інструкцій, які виконуються всерединіпокицикл називається тілом циклу ;
якщо умова єпомилковий(дорівнює нулю) як тільки воно тестується вперше, тіло не виконується жодного разу (зверніть увагу на аналогію, коли нічого не потрібно робити, якщо нічого робити);
тіло повинно мати можливість змінити значення умови, оскільки якщо умова єправдана початку тіло може працювати безперервно до нескінченності – зауважте, що виконання певної справи зазвичай зменшує кількість справ, які потрібно зробити).
3.2.2 Нескінченний цикл
Нескінченний цикл, також званий нескінченним циклом , — це послідовність інструкцій у програмі, які повторюються нескінченно (нескінченно).

Ось приклад циклу, який не може завершити своє виконання:


while True:
    print("I'm stuck inside a loop.")
 
Цей цикл друкуватиме нескінченно«Я застряг у петлі».на екрані.

  Примітка  
Якщо ви хочете отримати найкращий досвід навчання, спостерігаючи, як поводиться нескінченний цикл, запустіть IDLE, створіть новий файл, скопіюйте та вставте наведений вище код, збережіть свій файл і запустіть програму. Ви побачите нескінченну послідовність«Я застряг у петлі».рядки, надруковані у вікні консолі Python. Щоб завершити програму, просто натисніть Ctrl-C (або Ctrl-Break на деяких комп’ютерах). Це спричинить aKeyboardInterruptі дозвольте вашій програмі вийти з циклу. Ми поговоримо про це пізніше в курсі.

Давайте повернемося до ескізу алгоритму, який ми вам нещодавно показали. Ми збираємося показати вам, як використовувати цей нещодавно вивчений цикл, щоб знайти найбільше число з великого набору введених даних.

Уважно проаналізуйте програму. Подивіться, де починається цикл (рядок 8). Знайдіть тіло циклу та дізнайтеся, як з нього виходить :


# Store the current largest number here.
largest_number = -999999999
 
# Input the first value.
number = int(input("Enter a number or type -1 to stop: "))
 
# If the number is not equal to -1, continue.
while number != -1:
    # Is number larger than largest_number?
    if number > largest_number:
        # Yes, update largest_number.
        largest_number = number
    # Input the next number.
    number = int(input("Enter a number or type -1 to stop: "))
 
# Print the largest number.
print("The largest number is:", largest_number)
 
Перевірте, як цей код реалізує алгоритм, який ми показали вам раніше.

3.2.3 Цикл while : більше прикладів
Давайте розглянемо інший приклад використанняпокипетля. Слідкуйте за коментарями, щоб дізнатися ідею та рішення.


# A program that reads a sequence of numbers
# and counts how many numbers are even and how many are odd.
# The program terminates when zero is entered.
 
odd_numbers = 0
even_numbers = 0
 
# Read the first number.
number = int(input("Enter a number or type 0 to stop: "))
 
# 0 terminates execution.
while number != 0:
    # Check if the number is odd.
    if number % 2 == 1:
        # Increase the odd_numbers counter.
        odd_numbers += 1
    else:
        # Increase the even_numbers counter.
        even_numbers += 1
    # Read the next number.
    number = int(input("Enter a number or type 0 to stop: "))
 
# Print results.
print("Odd numbers count:", odd_numbers)
print("Even numbers count:", even_numbers)
 
Деякі вирази можна спростити, не змінюючи поведінку програми.

Спробуйте пригадати, як Python інтерпретує істинність умови, і зауважте, що ці дві форми еквівалентні:

а число != 0:іа число:.

Умову, яка перевіряє, чи є число непарним, також можна закодувати в цих еквівалентних формах:

якщо число % 2 == 1:іякщо число % 2:.

Використання змінної лічильника для виходу з циклу
Подивіться на фрагмент нижче:


counter = 5
while counter != 0:
    print("Inside the loop.", counter)
    counter -= 1
print("Outside the loop.", counter)
 
Цей код призначений для друку рядка«Всередині петлі».і значення, що зберігається влічильникзмінна протягом певного циклу рівно п’ять разів. Якщо умова не виконана (лічильникзмінна досягла0), цикл вийшов, і повідомлення«Поза петлею».а також значення, що зберігається влічильникдрукується.

Але є одне, що можна написати стисло – це станпокипетля.

Ви бачите різницю?


counter = 5
while counter:
    print("Inside the loop.", counter)
    counter -= 1
print("Outside the loop.", counter)
 
Він більш компактний, ніж раніше? Трохи. Це більш розбірливо? Це спірно.

  ПАМ'ЯТАЙТЕ  
Не вважайте себе зобов’язаним кодувати свої програми так, щоб вони завжди були найкоротшими та найкомпактнішими. Читабельність може бути більш важливим фактором. Тримайте свій код напоготові для нового програміста.



3.2.5 Зациклення коду за допомогою for
Інший тип циклу, доступний у Python, походить із спостереження, що іноді важливіше підрахувати «обороти» циклу, ніж перевіряти умови.

Уявіть, що тіло циклу потрібно виконати рівно сто разів. Якщо ви хочете використовуватипокицикл, щоб це зробити, це може виглядати так:


i = 0
while i < 100:
    # do_something()
    i += 1
 
Було б чудово, якби хтось міг зробити цей нудний підрахунок за вас. Чи це можливо?

Звичайно, є спеціальний цикл для таких завдань, і він називаєтьсядля.

Насправді,дляцикл призначений для виконання більш складних завдань – він може «переглядати» великі колекції даних по елементах . Незабаром ми покажемо вам, як це зробити, а зараз ми представимо більш простий варіант його застосування.

Подивіться на фрагмент:


for i in range(100):
    # do_something()
    pass
 
Є деякі нові елементи. Розповімо вам про них:

ключове слово for відкриваєдляпетля; примітка – після неї немає умови; вам не потрібно думати про умови, оскільки вони перевіряються внутрішньо, без стороннього втручання;
будь-яка змінна після ключового слова for є керуючою змінною циклу; він підраховує оберти петлі, і робить це автоматично;
ключове слово in вводить елемент синтаксису, що описує діапазон можливих значень, що призначаються керуючій змінній;
вдіапазон()функція (це дуже особлива функція) відповідає за генерування всіх бажаних значень керуючої змінної; у нашому прикладі функція створить (можна навіть сказати, що заповнить цикл ) наступні значення з наступного набору: 0, 1, 2 .. 97, 98, 99; Примітка: у цьому випадку,діапазон()функція починає свою роботу з 0 і закінчує її за крок (одне ціле число) до значення свого аргументу;
зверніть увагу на ключове слово pass всередині тіла циклу – воно взагалі нічого не робить; це порожня інструкція – ми розмістили її тут, тому щодлясинтаксис циклу вимагає принаймні однієї інструкції всередині тіла (до речі –якщо,elif,іншеіпокивисловити те саме)
Наші наступні приклади будуть трохи скромнішими за кількістю повторів циклу.

Подивіться на фрагмент нижче. Чи можете ви передбачити його вихід?

play_arrow
sync
download
light_mode
dark_mode
Console 
terminal
sync
Запустіть код, щоб перевірити, чи ви мали рацію.

Примітка:

цикл було виконано десять разів (цедіапазон()аргумент функції)
останнє значення контрольної змінної9(ні10, як це починається з0, а не з1)
Theдіапазон()виклик функції може мати два аргументи, а не один:


for i in range(2, 8):
    print("The value of i is currently", i)
 
У цьому випадку перший аргумент визначає початкове (перше) значення керуючої змінної.

Останній аргумент показує перше значення, яке не буде присвоєно керуючій змінній.

Примітка:діапазон()функція приймає лише цілі числа як аргументи та генерує послідовності цілих чисел.

Чи можете ви вгадати результат програми? Запустіть його, щоб перевірити, чи ви були правильні зараз.

Перше показано значення2(взято здіапазон()перший аргумент.)

Останнє є7(хочадіапазон()другий аргумент8).

3.2.6 Докладніше про цикл for і функцію range() із трьома аргументами
Theдіапазон()функція також може приймати три аргументи – подивіться на код у редакторі.

play_arrow
sync
download
light_mode
dark_mode
Console 
terminal
sync
Третій аргумент — приріст — це значення, яке додається для керування змінною при кожному повороті циклу (як ви можете підозрювати, значення за замовчуванням приросту дорівнює 1 ).

Чи можете ви сказати нам, скільки рядків з’явиться в консолі та які значення вони будуть містити?

Запустіть програму, щоб дізнатися, чи ви праві.

Ви повинні побачити такі рядки у вікні консолі:
The value of i is currently 2
The value of i is currently 5
Вихід
Ти знаєш чому? Перший аргумент перейшов додіапазон()функція повідомляє нам, що таке початковий номер послідовності (отже2на виході). Другий аргумент повідомляє функції, де зупинити послідовність (функція генерує числа до числа, зазначеного другим аргументом, але не включає його). Нарешті, третій аргумент вказує на крок , який насправді означає різницю між кожним числом у послідовності чисел, згенерованих функцією.

2(стартовий номер) →5(2збільшити на 3 рівних5– число в діапазоні від 2 до 8) →8(5збільшити на 3 рівних8– число не входить у діапазон від 2 до 8, оскільки параметр stop не входить до послідовності чисел, згенерованих функцією.)

Примітка: якщо набір, створений за допомогоюдіапазон()функція порожня, цикл взагалі не виконуватиме своє тіло.

Так само як тут – виводу не буде:


for i in range(1, 1):
    print("The value of i is currently", i)
 
Примітка: набір, створений за допомогоюдіапазон()потрібно відсортувати в порядку зростання . Немає способу змуситидіапазон()щоб створити набір в іншій формі, колидіапазон()функція приймає рівно два аргументи. Це означає, щодіапазон()другий аргумент має бути більшим за перший.

Таким чином, тут також не буде виводу:


for i in range(2, 1):
    print("The value of i is currently", i)
 
Давайте подивимося на коротку програму, завдання якої — написати кілька перших ступенів двійки:

play_arrow
sync
download
light_mode
dark_mode
Console 
terminal
sync
Theекспозмінна використовується як керуюча змінна для циклу та вказує на поточне значення експоненти . Саме піднесення до степеня замінюється множенням на два. Оскільки 2 0 дорівнює 1, то 2 × 1 дорівнює 2 1 , 2 × 2 1 дорівнює 2 2 і так далі. Який найбільший показник степеня, для якого наша програма все ще друкує результат?

Запустіть код і перевірте, чи результат відповідає вашим очікуванням.

3.2.8 Оператори break і continue
Досі ми розглядали тіло циклу як неподільну та нерозривну послідовність інструкцій, які повністю виконуються на кожному повороті циклу. Однак, як розробник, ви можете зіткнутися з такими виборами:

здається, що немає необхідності продовжувати цикл в цілому; слід утриматися від подальшого виконання тіла циклу і піти далі;
виявляється, що вам потрібно почати наступний хід циклу, не завершуючи виконання поточного.
Python надає дві спеціальні інструкції для реалізації обох цих завдань. Скажімо для точності, що їх існування в мові не є обов’язковим – досвідчений програміст здатний закодувати будь-який алгоритм без цих інструкцій. Такі доповнення, які не покращують виразну силу мови, а лише спрощують роботу розробника, іноді називають синтаксичною цукеркою або синтаксичним цукром.

Ці дві інструкції:

перерва– негайно виходить із циклу та безумовно завершує роботу циклу; програма починає виконувати найближчу інструкцію після тіла циклу;
продовжувати– поводиться так, ніби програма раптово досягла кінця тіла; починається наступний хід і негайно перевіряється вираз умови.
Обидва ці слова є ключовими .

Зараз ми покажемо вам два простих приклади, щоб проілюструвати, як працюють дві інструкції. Подивіться на код у редакторі. Запустіть програму та проаналізуйте результат. Змініть код і експериментуйте.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
# break - example



Консоль 
термінал
синхронізація
Інструкції break і continue : більше прикладів
Повернемося до нашої програми, яка розпізнає найбільше серед введених чисел. Ми перетворимо його двічі, використовуючиперерваіпродовжуватиінструкції.

Проаналізуйте код і вирішіть, чи будете ви використовувати будь-який із них і як.

Theперерваваріант йде тут:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Запустіть, перевірте та експериментуйте з ним.

А теперпродовжувативаріант:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Подивіться уважно, користувач вводить перше число перед тим, як програма введепокипетля. Наступне число вводиться, коли програма вже знаходиться в циклі .

Знову ж таки – запустіть програму, протестуйте її та експериментуйте з нею.

3.2.12 The while loop and the else branch
Обидві петлі,покиідля, мають одну цікаву (і рідко використовувану) особливість.

Ми покажемо вам, як це працює – спробуйте самі оцінити, чи можна ним користуватися та чи можете ви жити без нього чи ні.

Іншими словами, спробуйте переконати себе, чи функція є цінною та корисною, чи це просто синтаксичний цукор.

Подивіться на фрагмент у редакторі. Наприкінці є щось дивне –іншеключове слово.

Як ви могли підозрювати, петлі можуть матиіншегілка теж, якякщоs .

Петляіншегілка завжди виконується один раз, незалежно від того, увійшов цикл у її тіло чи ні .

Чи можете ви вгадати результат? Запустіть програму, щоб перевірити, чи ви мали рацію.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Трохи змініть фрагмент, щоб цикл не мав жодного шансу виконати своє тіло навіть один раз:

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Theпокистан єпомилковийна початку – бачиш?

Запустіть і протестуйте програму та перевірте, чи єіншегілка була виконана чи ні.



3.2.16 РЕЗЮМЕ РОЗДІЛУ
1. У Python існує два типи циклів:покиідля:

впокицикл виконує інструкцію або набір інструкцій до тих пір, поки вказана булева умова істинна, наприклад:

# Example 1
while True:
    print("Stuck in an infinite loop.")
 
# Example 2
counter = 5
while counter > 2:
    print(counter)
    counter -= 1
 
вдляцикл виконує набір операторів багато разів; він використовується для повторення послідовності (наприклад, списку, словника, кортежу або набору – ви дізнаєтесь про них незабаром) або інших ітерованих об’єктів (наприклад, рядків). Ви можете використовуватидляцикл для повторення послідовності чисел за допомогою вбудованогодіапазонфункція. Подивіться на приклади нижче:

# Example 1
word = "Python"
for letter in word:
    print(letter, end="*")
 
# Example 2
for i in range(1, 10):
    if i % 2 == 0:
        print(i)
 
2. Ви можете використовуватиперерваіпродовжуватиоператори для зміни потоку циклу:

Ти використовуєшперерващоб вийти з циклу, наприклад:

text = "OpenEDG Python Institute"
for letter in text:
    if letter == "P":
        break
    print(letter, end="")
 
Ти використовуєшпродовжуватищоб пропустити поточну ітерацію та продовжити наступну ітерацію, наприклад:

text = "pyxpyxpyx
for letter in text:
    if letter == "x":
        continue
    print(letter, end="")
 
3. Theпокиідляпетлі також можуть мати аніншепункт у Python. Theіншепункт виконується після завершення виконання циклу, доки його не було припиненоперерва, наприклад:


n = 0
 
while n != 3:
    print(n)
    n += 1
else:
    print(n, "else")
 
print()
 
for i in range(0, 3):
    print(i)
else:
    print(i, "else")
 
4. Theдіапазон()функція генерує послідовність чисел. Він приймає цілі числа та повертає об’єкти діапазону. Синтаксисдіапазон()виглядає наступним чином:діапазон (початок, зупинка, крок), де:

початокє необов'язковим параметром, який визначає початковий номер послідовності ( за умовчанням 0 )
СТІЙє необов'язковим параметром, що визначає кінець згенерованої послідовності (він не включений),
ікрокє необов’язковим параметром, який визначає різницю між числами в послідовності ( 1 за замовчуванням.)
Приклад коду:


for i in range(3):
    print(i, end=" ")  # Outputs: 0 1 2
 
for i in range(6, 1, -2):
    print(i, end=" ")  # Outputs: 6, 4, 2
 

3.3. Section 3 – Logic and bit operations in Python


3.3.1 Комп'ютерна логіка

Ви помітили, що умови, які ми використовували досі, були дуже простими, щоб не сказати, досить примітивними? Умови, які ми використовуємо в реальному житті, набагато складніші. Давайте подивимося на це речення:

Якщо у нас буде вільний час,іпогода хороша, підемо гуляти.

Ми використали сполучникі, а це означає, що вихід на прогулянку залежить від одночасного виконання цих двох умов. Мовою логіки такий зв'язок умов називається кон'юнкцією . А тепер інший приклад:

Якщо ви в торговому центріабоЯ в торговому центрі, хтось із нас купить мамі подарунок.

Поява словаабоозначає, що покупка залежить принаймні від однієї з цих умов. У логіці така сполука називається диз'юнкцією .

Зрозуміло, що Python повинен мати оператори для побудови кон’юнкції та диз’юнкції. Без них виражальна сила мови була б істотно ослаблена. Вони називаються логічними операторами .

Оператор and​
Одним з логічних операторів кон’юнкції в Python є слово and . Це бінарний оператор із пріоритетом, нижчим за той, який виражають оператори порівняння . Це дозволяє нам кодувати складні умови без використання таких дужок, як ця:


counter > 0 and value == 100
 
Результат, наданийіоператор можна визначити на основі таблиці істинності .

Якщо розглядати кон'юнкціюАіБмножина можливих значень аргументів і відповідних значень кон'юнкції виглядає наступним чином:



Оператор або​
Оператор диз'юнкції - це словоабо. Це бінарний оператор із нижчим пріоритетом ніжі(так як+у порівнянні з*). Його таблиця істинності виглядає наступним чином:



Оператор not​
Крім того, є ще один оператор, який можна застосувати до побудови умов. Це унарний оператор, який виконує логічне заперечення . Його дія проста: він перетворює правду на брехню, а брехню на правду.

Цей оператор записується як словоні, і його пріоритет дуже високий: такий самий, як і унарний+і-. Його таблиця істинності проста:


3.3.2 Логічні вирази
Давайте створимо змінну з назвоюварі призначити1до нього. Наступні умови попарно еквівалентні :


# Example 1:
print(var > 0)
print(not (var <= 0))
 
 
# Example 2:
print(var != 0)
print(not (var == 0))
 
Можливо, ви знайомі із законами Де Моргана. Вони кажуть, що:

Заперечення кон’юнкції — це диз’юнкція заперечень.

Заперечення диз'юнкції є сполученням заперечень.

Давайте напишемо те саме за допомогою Python:


not (p and q) == (not p) or (not q)
not (p or q) == (not p) and (not q)
 
Зверніть увагу на те, як дужки використовувалися для кодування виразів – ми розмістили їх там, щоб покращити читабельність.

Слід додати, що жоден із цих операторів із двома аргументами не можна використовувати у скороченій формі, відомій якop=. Цей виняток варто пам’ятати.

3.3.3 Логічні значення проти окремих бітів
Логічні оператори сприймають свої аргументи як єдине ціле незалежно від того, скільки бітів вони містять. Оператори знають лише значення: означає нуль (коли всі біти скинуто).помилковий; не нуль (якщо встановлено хоча б один біт) означаєправда.

Результатом їх діяльності є одне з таких значень:помилковийабоправда. Це означає, що цей фрагмент призначатиме значенняправдадоjзмінна ifiне дорівнює нулю; інакше будепомилковий.


i = 1
j = not not i
 
3.3.4 Порозрядні оператори
Однак є чотири оператори, які дозволяють маніпулювати окремими бітами даних . Вони називаються побітовими операторами .

Вони охоплюють усі операції, які ми згадували раніше в логічному контексті, і один додатковий оператор. Цеxor(як у виключному або ) операторі, і позначається як^(каретка).

Ось усі вони:

&(амперсанд) ‒ розрядний сполучник;
|(такт) ‒ порозрядна диз'юнкція;
~(тильда) ‒ порозрядне заперечення;
^(caret) ‒ порозрядне виключення або (xor).



Давайте зробимо це простіше:

&потрібно рівно два1s надавати1як результат;
|вимагає принаймні одного1забезпечувати1як результат;
^вимагає рівно один1забезпечувати1як результат.
Додамо важливе зауваження: аргументи цих операторів мають бути цілими ; ми не повинні використовувати поплавці тут.

Різниця в роботі логічних і бітових операторів важлива: логічні оператори не проникають на бітовий рівень свого аргументу . Їх цікавить лише кінцеве ціле число.

Побітові оператори суворіші: вони мають справу з кожним бітом окремо . Якщо ми припустимо, що ціла змінна займає 64 біти (що часто зустрічається в сучасних комп’ютерних системах), ви можете уявити собі порозрядну операцію як 64-кратну оцінку логічного оператора для кожної пари бітів аргументів. Ця аналогія, очевидно, недосконала, оскільки в реальному світі всі ці 64 операції виконуються одночасно (одночасно).

Логічні проти бітових операцій
Зараз ми покажемо вам приклад різниці в роботі між логічними та бітовими операціями. Припустимо, що виконано наступні завдання:


i = 15
j = 22
 
Якщо ми припустимо, що цілі числа зберігаються з 32 бітами, порозрядне зображення двох змінних буде таким:

i: 00000000000000000000000000001111
j: 00000000000000000000000000010110
Дається завдання:


log = i and j
 
Тут ми маємо справу з логічним сполученням. Простежимо хід розрахунків. Обидві змінніiіjне є нулями, тому буде вважатися таким, що представляєправда. Консультації з таблицею істинності дляіоператора, ми бачимо, що результат будеправда. Інші операції не виконуються.

log: True
Тепер порозрядна операція ‒ ось вона:


bit = i & j
 
The&оператор буде працювати з кожною парою відповідних бітів окремо, виробляючи значення відповідних бітів результату. Отже, результат буде таким:

Ці біти відповідають цілому числу шести.

Давайте тепер подивимося на оператори заперечення. Спочатку логічне:


logneg = not i
 
Thelognegбуде встановлено значення змінноїпомилковий‒ більше нічого робити не потрібно.

Порозрядне заперечення виглядає так:


bitneg = ~i
 
Це може бути трохи дивно:bitnegзначення змінної є-16. Це може здатися дивним, але зовсім не так. Якщо ви хочете дізнатися більше, вам слід ознайомитися з двійковою системою числення та правилами, що регулюють доповнення до двох чисел.


Кожен із цих операторів із двома аргументами можна використовувати у скороченій формі . Ось приклади їх еквівалентних позначень:

3.3.5 Як ми маємо справу з окремими бітами?
Зараз ми покажемо вам, для чого можна використовувати побітові оператори. Уявіть, що ви розробник, зобов’язаний написати важливу частину операційної системи. Вам повідомили, що вам дозволено використовувати змінну, призначену таким чином:

flag_register = 0x1234
 
Змінна зберігає інформацію про різні аспекти роботи системи. Кожен біт змінної зберігає одне значення так/ні . Вам також сказали, що тільки один із цих бітів є вашим – третій (пам’ятайте, що біти нумеруються від нуля, причому біт з номером нуль є молодшим, а старший – номером 31). Інші біти не можна змінювати, оскільки вони призначені для зберігання інших даних. Ось ваш біт, позначений літероюx:

flag_register = 0000000000000000000000000000x000
 
Ви можете зіткнутися з такими завданнями:

1. Перевірте стан свого біта ‒ ви хочете дізнатися значення свого біта; порівняння всієї змінної з нулем нічого не дасть, оскільки решта бітів можуть мати абсолютно непередбачувані значення, але ви можете використовувати наступну властивість кон’юнкції:


x & 1 = x
x & 0 = 0
 
Якщо ви застосовуєте&операція доflag_registerзмінна разом із таким бітовим зображенням:

00000000000000000000000000001000
(зверніть увагу на1у вашій позиції біта), як результат, ви отримаєте один із таких рядків бітів:

000000000000000000000000000001000якщо ваш біт було встановлено на1
000000000000000000000000000000000якщо ваш біт було скинуто на0
Така послідовність нулів і одиниць, завданням якої є захоплення значення або зміна вибраних бітів, називається бітовою маскою .

Давайте створимо бітову маску для визначення стану вашого біта. Він повинен вказувати на третій біт . Цей біт має вагу2 3 = 8. Відповідну маску можна створити за допомогою такої декларації:


the_mask = 8
 
Ви також можете створити послідовність інструкцій залежно від стану вашого біта. Ось:


if flag_register & the_mask:
    # My bit is set.
else:
    # My bit is reset.
 
2. Скиньте свій біт – ви присвоюєте нуль біту, а всі інші біти повинні залишатися незмінними; скористаємося тією ж властивістю кон’юнкції, що й раніше, але скористаємося дещо іншою маскою – точно так, як показано нижче:

11111111111111111111111111110111
 
Зверніть увагу, що маска була створена в результаті заперечення всіх бітівмасказмінна. Скидання біта просте і виглядає так (вибирайте той, який вам більше подобається):


flag_register = flag_register & ~the_mask
flag_register &= ~the_mask
 
3. Встановіть свій біт – ви призначаєте a1до вашого біта, тоді як всі інші біти повинні залишатися незмінними; використовуйте наступну властивість диз'юнкції:


x | 1 = 1
x | 0 = x
 
Тепер ви готові встановити свій біт за допомогою однієї з наведених нижче інструкцій:


flag_register = flag_register | the_mask
flag_register |= the_mask
 
4. Заперечуєте свій біт – ви замінюєте a1з0і а0з1. Можна використовувати цікаву властивістьxorоператор:


x ^ 1 = ~x
x ^ 0 = x
 
і заперечуйте свій біт за такими інструкціями:


flag_register = flag_register ^ the_mask
flag_register ^= the_mask
 
3.3.6 Двійковий зсув ліворуч і двійковий зсув праворуч
Python пропонує ще одну операцію, що стосується окремих бітів: shifting . Це застосовується лише до цілих значень, і ви не повинні використовувати числа з плаваючою точкою як аргументи для цього.

Ви вже застосовуєте цю операцію дуже часто і зовсім несвідомо. Як помножити будь-яке число на десять? Поглянь:

12345 × 10 = 123450

Як бачите, множення на десять – це фактично зсув усіх цифр вліво і заповнення отриманого пропуску нулем.

Ділення на десять? Поглянь:

12340 ÷ 10 = 1234

Ділення на десять - це не що інше, як зсув цифр вправо.

Комп’ютер виконує ту саму операцію, але з однією відмінністю: оскільки двійка є основою для двійкових чисел (а не 10), зсув значення на один біт ліворуч відповідає його множенню на два ; відповідно, зсув на один біт праворуч схожий на ділення на два (зауважте, що крайній правий біт втрачається).

Оператори зсуву в Python являють собою пару орграфів :<<і>>, чітко підказуючи, в якому напрямку буде діяти зсув.

value << bits
value >> bits
 
Лівим аргументом цих операторів є ціле число, біти якого зсунуті. Правильний аргумент визначає величину зсуву.

Це показує, що ця операція, звичайно, не є комутативною.

Пріоритет цих операторів дуже високий. Ви побачите їх в оновленій таблиці пріоритетів, яку ми покажемо вам у кінці цього розділу.

Подивіться на зрушення у вікні редактора.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Останнійдрукувати()виклик дає такий результат:

17 68 8
Вихід
Примітка:

17 >> 1→17 // 2( 17 поверхів поділити на 2 у степені 1 ) →8(зрушення вправо на один біт те саме, що ціле числове ділення на два)
17 << 2→17 * 4( 17 помножити на 2 у степені 2 ) →68(зрушення вліво на два біти те ж саме, що множення цілого числа на чотири)
А ось оновлена ​​таблиця пріоритетів , що містить усі введені на даний момент оператори:

Неповний 
3.3.7 РЕЗЮМЕ РОЗДІЛУ
3.3.7 РЕЗЮМЕ РОЗДІЛУ
1. Python підтримує такі логічні оператори:

і→ якщо обидва операнди істинні, умова істинна, наприклад,(Правда і правда)єправда,
або→ якщо будь-який з операндів є істинним, умова є істинною, наприклад,(Правда чи брехня)єправда,
ні→ повертає false, якщо результат істинний, і повертає true, якщо результат хибний, наприклад,неправдаєпомилковий.
2. Ви можете використовувати побітові оператори для маніпулювання окремими бітами даних. Наступні приклади даних:

х = 15, який0000 1111у двійковій системі,
y = 16, який0001 0000у двійковій системі.
буде використано для ілюстрації значення побітових операторів у Python. Проаналізуйте наведені нижче приклади.

&виконує побітове і , наприклад,x & y = 0, який0000 0000у двійковій системі,
|виконує побітове або , наприклад,х | y = 31, який0001 1111у двійковій системі,
˜робить порозрядно не , наприклад,˜ x = 240*, який1111 0000у двійковій системі,
^виконує порозрядний xor , наприклад,x ^ y = 31, який0001 1111у двійковій системі,
>>виконує побітовий зсув вправо , наприклад,y >> 1 = 8, який0000 1000у двійковій системі,
<<робить порозрядний зсув вліво , наприклад,y << 3 = 128, який1000 0000у двійковій системі.
*-16(десяткове число від доповнення до двійки) -- дізнайтеся більше про операцію доповнення до двійки .
> Ці логічні принципи можна пояснити простими словами за допомогою прикладів.

Заперечення кон’юнкції — це диз’юнкція заперечень
Це означає, що якщо ми маємо дві умови, скажімо, A і B, і хочемо заперечити їх одночасне виконання (кон'юнкцію A і B), то це те саме, що сказати, що принаймні одна з них не виконується (диз'юнкція заперечень A і B).

Простіше кажучи:

Кон'юнкція (AND): A і B повинні бути істинними одночасно.
Диз'юнкція (OR): Принаймні одна з умов повинна бути істинною.
Формально це виглядає так:

Заперечення кон’юнкції: NOT (A AND B)
Диз’юнкція заперечень: (NOT A) OR (NOT B)
Приклад:

A: "Я піду в кіно".
B: "Я піду в ресторан".
Кон’юнкція (A AND B): "Я піду в кіно і в ресторан".
Заперечення кон’юнкції: "Це не так, що я піду в кіно і в ресторан" (NOT (A AND B)).
Диз’юнкція заперечень: "Я не піду в кіно або я не піду в ресторан" ((NOT A) OR (NOT B)).
Отже, якщо ми заперечуємо твердження "Я піду в кіно і в ресторан", це рівнозначно тому, що ми стверджуємо "Я не піду в кіно або я не піду в ресторан".

Заперечення диз'юнкції є сполученням заперечень
Це означає, що якщо ми маємо дві умови, скажімо, A і B, і хочемо заперечити їх альтернативне виконання (диз'юнкцію A і B), то це те саме, що сказати, що обидві умови не виконуються одночасно (кон'юнкція заперечень A і B).

Простіше кажучи:

Диз’юнкція (OR): Принаймні одна з умов повинна бути істинною.
Кон'юнкція (AND): Обидві умови повинні бути істинними одночасно.
Формально це виглядає так:

Заперечення диз'юнкції: NOT (A OR B)
Кон'юнкція заперечень: (NOT A) AND (NOT B)
Приклад:

A: "Я піду в кіно".
B: "Я піду в ресторан".
Диз'юнкція (A OR B): "Я піду в кіно або в ресторан".
Заперечення диз'юнкції: "Це не так, що я піду в кіно або в ресторан" (NOT (A OR B)).
Кон'юнкція заперечень: "Я не піду в кіно і я не піду в ресторан" ((NOT A) AND (NOT B)).
Отже, якщо ми заперечуємо твердження "Я піду в кіно або в ресторан", це рівнозначно тому, що ми стверджуємо "Я не піду в кіно і я не піду в ресторан".

Таким чином, ці логічні принципи допомагають нам зрозуміти, як заперечення впливає на об'єднання та розділення умов.
Логічні оператори в Python працюють з аргументами, розглядаючи їх як істинні або хибні значення, незалежно від того, скільки бітів вони містять. Якщо значення не є нулем, воно вважається істинним; якщо значення нуль, воно вважається хибним.

Пояснення з прикладами:
i = 1

Змінна i містить значення 1, яке є істинним.
j = not i

not - це логічний оператор, який заперечує значення. Якщо i істинне (1), то not i буде хибним.
Отже, j буде False.
j = not not i

Спочатку виконується внутрішнє not i, яке перетворює 1 на False.
Потім виконується зовнішнє not, яке перетворює False на True.
Отже, j буде True.
j = not not not i

Спочатку виконується внутрішнє not i, яке перетворює 1 на False.
Потім наступне not перетворює False на True.
Нарешті, зовнішнє not перетворює True на False.
Отже, j буде False.
j = not not not not i

Спочатку виконується внутрішнє not i, яке перетворює 1 на False.
Потім наступне not перетворює False на True.
Далі наступне not перетворює True на False.
Нарешті, зовнішнє not перетворює False на True.
Отже, j буде True.
Висновок:
Логічний оператор not змінює значення на протилежне:

not True стає False
not False стає True
При додаванні кількох not одне за одним, ми просто перемикаємо значення з істинного на хибне або навпаки. Це працює так:

Кожне парне число not (наприклад, два not, чотири not) повертає нас до початкового значення.
Кожне непарне число not змінює початкове значення на протилежне.
Таким чином, ви можете використовувати подвійне not для перетворення будь-якого значення на його логічне представлення: True або False.

![img_3.png](img_3.png)
Логічні оператори
Логічні оператори працюють з істинністю (правда чи хибність) значень.

І (and)

Повертає True (істинне значення), якщо обидва операнди істинні.
Наприклад:
python
Копіювати код
True and True  # результат: True
True and False # результат: False
Або (or)

Повертає True (істинне значення), якщо хоча б один операнд істинний.
Наприклад:
python
Копіювати код
True or False  # результат: True
False or False # результат: False
Не (not)

Змінює значення на протилежне: True на False і навпаки.
Наприклад:
python
Копіювати код
not True  # результат: False
not False # результат: True
Побітові оператори
Побітові оператори працюють з окремими бітами чисел. Давайте розглянемо це на прикладі чисел x і y:

x = 15, що у двійковій системі виглядає як 0000 1111
y = 16, що у двійковій системі виглядає як 0001 0000
Побітове І (&)

Порівнює відповідні біти обох чисел і повертає 1 тільки там, де обидва біти рівні 1.
Наприклад:
python
Копіювати код
x & y  # результат: 0 (0000 0000 у двійковій системі)
Побітове Або (|)

Порівнює відповідні біти обох чисел і повертає 1 там, де хоча б один з бітів рівний 1.
Наприклад:
python
Копіювати код
x | y  # результат: 31 (0001 1111 у двійковій системі)
Побітове Не (~)

Змінює кожен біт на протилежний.
Наприклад:
python
Копіювати код
~x  # результат: -16 (1111 0000 у двійковій системі, що є -16 у десятковій системі)
Побітове XOR (^)

Порівнює відповідні біти обох чисел і повертає 1 тільки там, де біти різні.
Наприклад:
python
Копіювати код
x ^ y  # результат: 31 (0001 1111 у двійковій системі)
Побітовий зсув вправо (>>)

Зсуває біти вправо на вказану кількість позицій.
Наприклад:
python
Копіювати код
y >> 1  # результат: 8 (0000 1000 у двійковій системі)
Побітовий зсув вліво (<<)

Зсуває біти вліво на вказану кількість позицій.
Наприклад:
python
Копіювати код
y << 3  # результат: 128 (1000 0000 у двійковій системі)
Додаток про Доповнення до Двійки
Коли ми говоримо про ~x і отримуємо -16, це відбувається через операцію доповнення до двійки. Ось як це працює:

Інвертуємо всі біти числа x:

x = 15 (0000 1111)
Інверсія: (1111 0000)
Додаємо 1 до результату інверсії:

(1111 0000) + 1 = (1111 0001)
У десятковій системі це еквівалентно -16:

Отримуємо -16.
Висновок
Логічні оператори в Python працюють з істинними і хибними значеннями, а побітові оператори працюють безпосередньо з бітами чисел. Кожен оператор має свій спосіб обробки значень і призначений для різних типів задач.

Звісно! Давайте розглянемо кожну операцію окремо на основі чисел x = 4 і y = 1, а також виведемо результати.

Побітові оператори
1. Побітове І (&)
python
Копіювати код
a = x & y
x = 4 у двійковій системі: 0100
y = 1 у двійковій системі: 0001
Виконуємо побітове І:
markdown
Копіювати код
0100
& 0001
-----
0000
Результат: 0
2. Побітове Або (|)
python
Копіювати код
b = x | y
x = 4 у двійковій системі: 0100
y = 1 у двійковій системі: 0001
Виконуємо побітове Або:
markdown
Копіювати код
0100
| 0001
-----
0101
Результат: 5
3. Побітове Не (~)
python
Копіювати код
c = ~x  # tricky!
x = 4 у двійковій системі: 0100
Виконуємо побітове Не, інвертуємо всі біти:
yaml
Копіювати код
0100 -> 1011 (інверсія бітів)
У системі доповнення до двійки (two's complement) це:
yaml
Копіювати код
1011 = -5
Результат: -5
4. Побітове XOR (^)
python
Копіювати код
d = x ^ 5
x = 4 у двійковій системі: 0100
5 у двійковій системі: 0101
Виконуємо побітове XOR:
markdown
Копіювати код
0100
^ 0101
-----
0001
Результат: 1
5. Побітовий зсув вправо (>>)
python
Копіювати код
e = x >> 2
x = 4 у двійковій системі: 0100
Зсуваємо біти вправо на 2 позиції:
yaml
Копіювати код
0100 >> 2 = 0001
Результат: 1
6. Побітовий зсув вліво (<<)
python
Копіювати код
f = x << 2
x = 4 у двійковій системі: 0100
Зсуваємо біти вліво на 2 позиції:
bash
Копіювати код
0100 << 2 = 10000
Результат: 16
Результат виконання коду
python
Копіювати код
print(a, b, c, d, e, f)
Виведе:

Копіювати код
0 5 -5 1 1 16
Пояснення
a = x & y результат: 0 (побітове І)
b = x | y результат: 5 (побітове Або)
c = ~x результат: -5 (побітове Не, з використанням доповнення до двійки)
d = x ^ 5 результат: 1 (побітове XOR)
e = x >> 2 результат: 1 (зсув вправо)
f = x << 2 результат: 16 (зсув вліво)
Кожен з цих результатів отримано завдяки маніпуляціям з бітами чисел x і y у двійковій системі.


3.4. Розділ 4 – Списки

3.4.1 Навіщо нам потрібні списки?

Може трапитися так, що вам доведеться прочитати, зберегти, обробити і, зрештою, надрукувати десятки, а може й сотні, а може й тисячі чисел. Що потім? Вам потрібно створити окрему змінну для кожного значення? Вам доведеться витрачати довгі години на написання заяв, подібних до наведеного нижче?

var1 = int(input())
var2 = int(input())
var3 = int(input())
var4 = int(input())
var5 = int(input())
var6 = int(input())
:
:
 
Якщо вам здається, що це не складне завдання, то візьміть аркуш паперу і напишіть програму, яка:

читає п'ять чисел;
друкує їх у порядку від найменшого до найбільшого (зверніть увагу, такий вид обробки називається сортуванням ).
Ви повинні виявити, що у вас навіть не вистачає паперу, щоб виконати завдання.

Поки що ви навчилися оголошувати змінні, здатні зберігати точно одне задане значення за раз. Такі змінні іноді називають скалярами за аналогією з математикою. Усі змінні, які ви використовували досі, насправді є скалярами.

Подумайте, наскільки зручно було б оголосити змінну, яка могла б зберігати більше одного значення . Наприклад, сто, або тисяча, або навіть десять тисяч. Це все одно буде одна і та ж змінна, але дуже широка і ємна. Звучить привабливо? Можливо, але як він обробляє такий контейнер, повний різних значень? Як вибрати саме той, який вам потрібен?

Що, якби ви могли просто пронумерувати їх? А потім скажіть: дайте мені значення номер 2; присвоїти значення числа 15; збільшити значення числа 10000 .

Ми покажемо вам, як оголосити такі багатозначні змінні . Ми зробимо це на прикладі, який ми щойно запропонували. Ми напишемо програму, яка сортує послідовність чисел . Не будемо особливо амбітні – припустимо, що чисел рівно п’ять.

Давайте створимо змінну під назвоючисел; йому призначається не лише одне число, а заповнюється списком із п’яти значень (зверніть увагу: список починається відкритою квадратною дужкою та закінчується закритою квадратною дужкою ; простір між дужками заповнюється п’ятьма числами, розділеними комами ).

numbers = [10, 5, 7, 2, 1]
 
Скажемо те саме, використовуючи адекватну термінологію:чиселце список, що складається з п’яти значень, усі з яких є числами . Ми також можемо сказати, що цей оператор створює список довжиною, що дорівнює п’яти (оскільки в ньому є п’ять елементів).

Елементи всередині списку можуть мати різні типи . Деякі з них можуть бути цілими числами, інші плаваючими, а треті можуть бути списками.

Python прийняв угоду про те, що елементи в списку завжди нумеруються, починаючи з нуля . Це означає, що елемент, який зберігається на початку списку, матиме нульовий номер. Оскільки в нашому списку п'ять елементів, останньому з них присвоєно номер чотири. Не забувайте про це.

Ви скоро звикнете до цього, і це стане другою натурою.

Перш ніж продовжити нашу дискусію, ми маємо сказати наступне: наш список є набором елементів, але кожен елемент є скаляром .

3.4.2 Індексація списків
Як змінити значення вибраного елемента в списку?

Давайте призначимо нове значення111до першого елемента в списку. Ми робимо це так:


numbers = [10, 5, 7, 2, 1]
print("Original list contents:", numbers)  # Printing original list contents.
 
numbers[0] = 111
print("New list contents: ", numbers)  # Current list contents.
 
А тепер ми хочемо, щоб значення п’ятого елемента було скопійоване до другого елемента – можете здогадатися, як це зробити?


numbers = [10, 5, 7, 2, 1]
print("Original list contents:", numbers)  # Printing original list contents.
 
numbers[0] = 111
print("\nPrevious list contents:", numbers)  # Printing previous list contents.
 
numbers[1] = numbers[4]  # Copying value of the fifth element to the second.
print("New list contents:", numbers)  # Printing current list contents.
 
Значення в дужках, яке вибирає один елемент зі списку, називається індексом , а операція вибору елемента зі списку називається індексуванням .

Ми будемо використовуватидрукувати()функція для друку вмісту списку кожного разу, коли ми вносимо зміни. Це допоможе нам уважніше стежити за кожним кроком і бачити, що відбувається після певної зміни списку.

Примітка: усі індекси, що використовуються досі, є літеральними. Їх значення фіксовані під час виконання, але будь-який вираз також може бути індексом . Це відкриває багато можливостей.

3.4.3 Доступ до вмісту списку
До кожного з елементів списку можна отримати доступ окремо. Наприклад, його можна роздрукувати:


print(numbers[0]) # Accessing the list's first element.
 
Якщо припустити, що всі попередні операції виконано успішно, фрагмент буде надіслано111до консолі.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Як ви бачите в редакторі, список також може бути надрукований цілком - як тут:


print(numbers) # Printing the whole list.
 
Як ви, напевно, помічали раніше, Python прикрашає вихідні дані таким чином, що передбачає, що всі представлені значення утворюють список. Результат із наведеного вище прикладу виглядає так:

[111, 1, 7, 2, 1]
Вихід
Функція len ().
Довжина списку може змінюватися під час виконання. До списку можна додавати нові елементи, а інші – видаляти з нього. Це означає, що список є дуже динамічною сутністю.

Якщо ви хочете перевірити поточну довжину списку, ви можете скористатися функцією під назвоюlen()(його назва походить від length ).

Функція приймає ім’я списку як аргумент і повертає кількість елементів, які наразі зберігаються в списку (іншими словами – довжину списку).

Подивіться на останній рядок коду в редакторі, запустіть програму та перевірте, яке значення вона виведе на консоль. Ви можете здогадатися?

3.4.4 Видалення елементів зі списку
Будь-який з елементів списку можна видалити в будь-який момент – це робиться за допомогою інструкції з назвоюдел(видалити). Примітка: це інструкція , а не функція.

Ви повинні вказати на елемент, який потрібно видалити – він зникне зі списку, а довжина списку зменшиться на одиницю.

Подивіться на фрагмент нижче. Чи можете ви здогадатися, який результат це дасть? Запустіть програму в редакторі і перевірте.


del numbers[1]
print(len(numbers))
print(numbers)
 
Ви не можете отримати доступ до елемента, якого не існує – ви не можете ні отримати його значення, ні призначити йому значення. Обидві ці інструкції тепер спричинять помилки виконання:


print(numbers[4])
numbers[4] = 1
 
Додайте наведений вище фрагмент після останнього рядка коду в редакторі, запустіть програму та перевірте, що відбувається.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Примітка: ми видалили один із елементів списку – зараз у списку всього чотири елементи. Це означає, що елемент номер чотири не існує.

3.4.5 Від’ємні показники є допустимими
Це може здатися дивним, але негативні індекси є законними і можуть бути дуже корисними.

Елемент з індексом, рівним-1є останнім у списку .

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Виведеться приклад фрагмента1. Запустіть програму і перевірте.

Аналогічно, елемент з індексом, рівним-2є передостаннім у списку .

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Виведеться приклад фрагмента2.

Останній доступний елемент у нашому спискучисла[-4](перший) ‒ не намагайся йти далі!

3.4.7 Функції проти методів
Метод — це особливий тип функції : він веде себе як функція і виглядає як функція, але відрізняється способом, у який він діє, і стилем виклику.

Функція не належить жодним даним – вона отримує дані, може створювати нові дані та (загалом) створює результат.

Метод виконує всі ці дії, але також може змінювати стан вибраної сутності .

Метод належить даним, з якими він працює, тоді як функція належить всьому коду .

Це також означає, що виклик методу вимагає певної специфікації даних, з яких метод викликається.

Тут це може здатися загадковим, але ми розберемося з цим докладніше, коли заглибимося в об’єктно-орієнтоване програмування.

Загалом типовий виклик функції може виглядати так:

result = function(arg)
 
Функція приймає аргумент, щось робить і повертає результат.

Типовий виклик методу зазвичай виглядає так:

result = data.method(arg)
 
Примітка: назві методу передує назва даних, які володіють методом. Далі ви додаєте крапку , за якою слідує ім’я методу та пара круглих дужок, що містить аргументи .

Метод поводитиметься як функція, але може робити щось більше – він може змінювати внутрішній стан даних, з яких його було викликано.

Ви можете запитати: чому ми говоримо про методи, а не про списки?

Зараз це важлива проблема, оскільки ми збираємося показати вам, як додати нові елементи до існуючого списку. Це можна зробити за допомогою методів, які належать усім спискам, а не функціям.


3.4.8 Додавання елементів до списку: append() і insert()
Новий елемент можна приклеїти до кінця існуючого списку:

list.append(value)
 
Така операція виконується методом під назвоюдодати(). Він приймає значення свого аргументу та розміщує його в кінці списку , якому належить метод.

Тоді довжина списку збільшується на одиницю.

Theвставити()метод трохи розумніший – він може додати новий елемент у будь-яке місце списку , а не лише в кінці.

list.insert(location, value)
 
Потрібно два аргументи:

перший показує необхідне розташування елемента, що вставляється; примітка: усі існуючі елементи, які займають розташування праворуч від нового елемента (включаючи той, що знаходиться у вказаній позиції), зсуваються праворуч, щоб звільнити місце для нового елемента;
другий - це елемент, який потрібно вставити.
Подивіться на код у редакторі. Подивіться, як ми використовуємододати()івставити()методи. Зверніть увагу на те, що відбувається після використаннявставити(): колишній перший елемент тепер другий, другий третій і так далі.
3.4.8 Додавання елементів до списку: append() і insert()
Новий елемент можна приклеїти до кінця існуючого списку:

list.append(value)
 
Така операція виконується методом під назвоюдодати(). Він приймає значення свого аргументу та розміщує його в кінці списку , якому належить метод.

Тоді довжина списку збільшується на одиницю.

Theвставити()метод трохи розумніший – він може додати новий елемент у будь-яке місце списку , а не лише в кінці.

list.insert(location, value)
 
Потрібно два аргументи:

перший показує необхідне розташування елемента, що вставляється; примітка: усі існуючі елементи, які займають розташування праворуч від нового елемента (включаючи той, що знаходиться у вказаній позиції), зсуваються праворуч, щоб звільнити місце для нового елемента;
другий - це елемент, який потрібно вставити.
Подивіться на код у редакторі. Подивіться, як ми використовуємододати()івставити()методи. Зверніть увагу на те, що відбувається після використаннявставити(): колишній перший елемент тепер другий, другий третій і так далі.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
numbers = [111, 7, 2, 1]
print(len(numbers))


Консоль 
термінал
синхронізація

Додайте наступний фрагмент після останнього рядка коду в редакторі:


numbers.insert(1, 333)
 
Роздрукуйте вміст остаточного списку на екрані та подивіться, що станеться. Фрагмент вище вставляє333у список, роблячи його другим елементом. Колишній другий елемент стає третім, третій — четвертим і так далі.

Ви можете почати життя списку, зробивши його порожнім (це робиться за допомогою пустої пари квадратних дужок), а потім додавши до нього нові елементи за потреби.

Подивіться на фрагмент у редакторі. Спробуйте вгадати його вихід післядлявиконання циклу. Запустіть програму, щоб перевірити, чи ви мали рацію.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
my_list = []  # Creating an empty list.



Консоль 
термінал
синхронізація
Це буде послідовність послідовних цілих чисел з1(потім ви додаєте один до всіх доданих значень) до5.

Ми дещо змінили фрагмент:


my_list = []  # Creating an empty list.
 
for i in range(5):
    my_list.insert(0, i + 1)
 
print(my_list)
 
Що тепер відбувається? Запустіть програму і перевірте, чи цього разу ви також маєте рацію.

Ви повинні отримати таку ж послідовність, але у зворотному порядку (це перевага використаннявставити()метод).

3.4.9 Використання списків
Theдляloop має спеціальний варіант, який може дуже ефективно обробляти списки – давайте подивимося на це.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Припустімо, що ви хочете обчислити суму всіх значень, які зберігаються вмій_списоксписок .

Вам потрібна змінна, сума якої буде збережена та спочатку присвоєно значення0‒ буде його назвавсього. (Примітка: ми не будемо називати цесумаоскільки Python використовує таку саму назву для однієї зі своїх вбудованих функцій:сума(). Використання однієї назви зазвичай вважається поганою практикою .) Потім ви додаєте до нього всі елементи списку за допомогоюдляпетля. Подивіться на фрагмент у редакторі.

Прокоментуємо цей приклад:

списку присвоюється послідовність з п'яти цілих значень;
вiзмінна приймає значення0,1,2,3, і4, а потім індексує список, вибираючи наступні елементи: перший, другий, третій, четвертий і п'ятий;
кожен із цих елементів додається разом+=оператор довсьогозмінна, що дає кінцевий результат у кінці циклу;
зверніть увагу на спосіб, у якийlen()була використана функція ‒ вона робить код незалежним від будь-яких можливих змін у вмісті списку.
Другий аспект циклу for
Аледляцикл може зробити набагато більше. Він може приховати всі дії, пов’язані з індексацією списку, і доставити всі елементи списку в зручний спосіб.

Цей змінений фрагмент показує, як це працює:


my_list = [10, 1, 8, 3, 5]
total = 0
 
for i in my_list:
    total += i
 
print(total)
 

Що тут відбувається?

вдляінструкція вказує змінну, яка використовується для перегляду списку (iтут), а потімвключове слово та назву списку, що обробляється (мій_списоктут)
вiзмінній присвоюються значення всіх наступних елементів списку, і процес відбувається стільки разів, скільки елементів у списку;
це означає, що ви використовуєтеiзмінна як копія значень елементів, і вам не потрібно використовувати індекси;
вlen()функція тут також не потрібна.

3.4.10 Списки в дії
Давайте ненадовго залишимо списки осторонь і розглянемо одну інтригуючу проблему.

Уявіть, що вам потрібно переставити елементи списку, тобто змінити порядок елементів на протилежний: перший і п’ятий, а також другий і четвертий елементи поміняються місцями. Третій залишиться недоторканим.

Питання: як можна поміняти місцями значення двох змінних?

Подивіться на фрагмент:


variable_1 = 1
variable_2 = 2
 
variable_2 = variable_1
variable_1 = variable_2
 
Якщо ви зробите щось подібне, ви втратите значення, яке раніше зберігалося взмінна_2. Зміна порядку завдань не допоможе. Вам потрібна третя змінна, яка слугуватиме допоміжним сховищем .

Ось як ви можете це зробити:


variable_1 = 1
variable_2 = 2
 
auxiliary = variable_1
variable_1 = variable_2
variable_2 = auxiliary
 
Python пропонує більш зручний спосіб виконання обміну – подивіться:


variable_1 = 1
variable_2 = 2
 
variable_1, variable_2 = variable_2, variable_1
 
Чітко, ефектно і елегантно - чи не так?

Тепер ви можете легко поміняти місцями елементи списку, щоб змінити їх порядок:


my_list = [10, 1, 8, 3, 5]
 
my_list[0], my_list[4] = my_list[4], my_list[0]
my_list[1], my_list[3] = my_list[3], my_list[1]
 
print(my_list)
 
Запустіть фрагмент. Його результат має виглядати так:

[5, 3, 8, 1, 10]
Вихід
Добре виглядає з п'ятьма елементами.

Чи буде це прийнятно зі списком із 100 елементів? Ні, не буде.

Чи можете ви використовуватидляцикл, щоб зробити те саме автоматично, незалежно від довжини списку? Так, ти можеш.

Ось як ми це зробили:


for i in range(length // 2):
    my_list[i], my_list[length - i - 1] = my_list[length - i - 1], my_list[i]
 
print(my_list)
 
Примітка:

ми призначилидовжиназмінна з довжиною поточного списку (це робить наш код трохи зрозумілішим і коротшим)
ми запустилидляпетля, щоб пройти через його тілодовжина // 2разів (це добре працює для списків як парної, так і непарної довжини, оскільки, коли список містить непарну кількість елементів, середній залишається недоторканим)
ми поміняли i-й елемент (з початку списку) на елемент з індексом, рівним(довжина - i - 1)(з кінця списку); в нашому прикладі, дляiдорівнює0в(довжина - i - 1)дає4; дляiдорівнює1, це дає3‒ це саме те, що нам було потрібно.
Списки надзвичайно корисні, і ви будете часто з ними стикатися.


3.4.12 РЕЗЮМЕ РОЗДІЛУ
1. Список — це тип даних у Python, який використовується для зберігання кількох об’єктів . Це впорядкована та змінна колекція елементів, розділених комами в квадратних дужках, наприклад:


my_list = [1, None, True, "I am a string", 256, 0]
 
2. Списки можна індексувати та оновлювати , наприклад:


my_list = [1, None, True, 'I am a string', 256, 0]
print(my_list[3])  # outputs: I am a string
print(my_list[-1])  # outputs: 0
 
my_list[1] = '?'
print(my_list)  # outputs: [1, '?', True, 'I am a string', 256, 0]
 
my_list.insert(0, "first")
my_list.append("last")
print(my_list)  # outputs: ['first', 1, '?', True, 'I am a string', 256, 0, 'last']
 
3. Списки можуть бути вкладеними , наприклад:


my_list = [1, 'a', ["list", 64, [0, 1], False]]
 
Ви дізнаєтеся більше про вкладення в модулі {{_moduleNumber}}.7 ‒ поки що ми просто хочемо, щоб ви знали, що щось подібне теж можливо.

4. Елементи списку та списки можна видаляти , наприклад:


my_list = [1, 2, 3, 4]
del my_list[2]
print(my_list)  # outputs: [1, 2, 4]
 
del my_list  # deletes the whole list
 
Знову ж таки, ви дізнаєтеся більше про це в модулі {{_moduleNumber}}.6 ‒ не хвилюйтеся. Поки що просто спробуйте поекспериментувати з наведеним вище кодом і перевірити, як його зміна впливає на результат.

5. Списки можна повторювати за допомогоюдляцикл, наприклад:


my_list = ["white", "purple", "blue", "yellow", "green"]
 
for color in my_list:
    print(color)
 
6. Thelen()функція може бути використана для перевірки довжини списку , наприклад:


my_list = ["white", "purple", "blue", "yellow", "green"]
print(len(my_list))  # outputs 5
 
del my_list[2]
print(len(my_list))  # outputs 4
 
7. Типовий виклик функції виглядає наступним чином:результат = функція (арг), тоді як типовий виклик методу виглядає так:результат = дані.метод(арг).


3.5.1 Бульбашкове сортування

Тепер, коли ви можете ефективно жонглювати елементами списків, настав час навчитися їх сортувати . На даний момент винайдено багато алгоритмів сортування, які сильно відрізняються як швидкістю, так і складністю. Ми збираємося показати вам дуже простий алгоритм, простий для розуміння, але, на жаль, також не надто ефективний. Він використовується дуже рідко, і, звичайно, не для великих і розширених списків.

Скажімо, список можна відсортувати двома способами:

зростаюча (а точніше ‒ неспадна) ‒ якщо в кожній парі сусідніх елементів перший елемент не більший за другий;
спадаючу (а точніше ‒ незростаючу) ‒ якщо в кожній парі сусідніх елементів перший елемент не менший за другий.
У наступних розділах ми відсортуємо список у порядку зростання, щоб числа були впорядковані від найменшого до найбільшого.

Ось список:

Спробуємо застосувати наступний підхід: візьмемо перший і другий елементи і порівняємо їх; якщо ми визначимо, що вони в неправильному порядку (тобто перший більший за другий), ми поміняємо їх місцями; якщо їхній наказ дійсний, ми нічого не зробимо. Погляд на наш список підтверджує останнє – елементи 01 і 02 знаходяться в правильному порядку, як у8 < 10.

Тепер подивіться на другий і третій елементи. Вони займають неправильні позиції. Ми повинні поміняти їх місцями:

Йдемо далі, дивимося на третій і четвертий елементи. Знову ж таки, це не те, що має бути. Ми повинні поміняти їх місцями:

Тепер перевіряємо четвертий і п'ятий елементи. Так, вони теж на неправильних позиціях. Відбувається інший обмін:

Перший прохід по списку вже завершено. Ми ще далекі від завершення нашої роботи, але тим часом сталося щось цікаве. Найбільший елемент,10, вже дійшло до кінця списку. Зверніть увагу, що це бажане місце для цього. Всі решта елементів утворюють мальовничий безлад, але цей вже на місці.

А тепер на мить спробуйте уявити список трохи інакше, а саме так:

Подивіться ‒10знаходиться на вершині. Можна сказати, що воно спливло з дна на поверхню, як бульбашка в келиху з шампанським . Метод сортування отримав свою назву від того самого спостереження – він називається бульбашковим сортуванням .

Тепер ми починаємо з другого проходу по списку. Дивимося перший і другий елементи - потрібен своп:

Час для другого і третього елементів: їх теж потрібно поміняти місцями:

Тепер третій і четвертий елементи, і другий прохід закінчений, як8вже на місці:

Одразу починаємо наступний прохід. Уважно стежте за першим і другим елементами - потрібна ще одна заміна:

Зараз6потрібно стати на місце. Міняємо місцями другий і третій елементи:

Список уже впорядковано. Нам більше нічого робити. Це саме те, чого ми хочемо.

Як бачите, суть цього алгоритму проста: ми порівнюємо сусідні елементи, і, помінявши деякі з них місцями, досягаємо мети .

Давайте закодуємо на Python усі дії, які виконуються під час одного проходу списку, а потім розглянемо, скільки проходів нам насправді потрібно для його виконання. Ми ще не пояснювали цього, і зробимо це трохи пізніше.

3.5.2 Сортування списку
Скільки пропусків нам потрібно, щоб відсортувати весь список?

Ми вирішуємо це питання наступним чином: вводимо ще одну змінну ; його завдання полягає в тому, щоб спостерігати, чи було зроблено будь-який своп під час проходу чи ні; якщо обміну немає, то список уже відсортовано, і більше нічого робити не потрібно. Ми створюємо змінну з іменемпоміняні місцями, і ми присвоюємо значенняпомилковийдо нього, щоб вказати, що обмінів немає. В іншому випадку його буде призначеноправда.


my_list = [8, 10, 6, 2, 4]  # list to sort
 
for i in range(len(my_list) - 1):  # we need (5 - 1) comparisons
    if my_list[i] > my_list[i + 1]:  # compare adjacent elements
        my_list[i], my_list[i + 1] = my_list[i + 1], my_list[i]  # If we end up here, we have to swap the elements.
 
Ви повинні без проблем читати та розуміти цю програму:


my_list = [8, 10, 6, 2, 4]  # list to sort
swapped = True  # It's a little fake, we need it to enter the while loop.
 
while swapped:
    swapped = False  # no swaps so far
    for i in range(len(my_list) - 1):
        if my_list[i] > my_list[i + 1]:
            swapped = True  # a swap occurred!
            my_list[i], my_list[i + 1] = my_list[i + 1], my_list[i]
 
print(my_list)
 
Запустіть програму та протестуйте її.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація

3.5.3 Бульбашкове сортування – інтерактивна версія
У редакторі ви можете побачити повну програму, збагачену розмовою з користувачем, яка дозволяє користувачеві вводити та друкувати елементи зі списку: Бульбашкове сортування ‒ остаточна інтерактивна версія .

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Однак Python має власні механізми сортування. Нікому не потрібно писати власні сорти, оскільки є достатня кількість готових до використання інструментів .

Ми пояснили вам цю систему сортування, оскільки важливо навчитися обробляти вміст списку та показати вам, як може працювати справжнє сортування.

Якщо ви хочете, щоб Python сортував ваш список, ви можете зробити це так:


my_list = [8, 10, 6, 2, 4]
my_list.sort()
print(my_list)
 
Це так просто.

Вихід фрагмента такий:

[2, 4, 6, 8, 10]
Вихід
Як бачите, усі списки мають назву методуsort(), який сортує їх якомога швидше. Ви вже дізналися про деякі методи списку раніше, а про інші ви дізнаєтеся більше незабаром.

Неповний 
3.5.4 РЕЗЮМЕ РОЗДІЛУ
3.5.4 РЕЗЮМЕ РОЗДІЛУ
1. Ви можете використовуватиsort()метод сортування елементів списку, наприклад:


lst = [5, 3, 1, 2, 4]
print(lst)
 
lst.sort()
print(lst)  # outputs: [1, 2, 3, 4, 5]
 
2. Існує також метод списку, який називаєтьсязворотний(), за допомогою якого можна перевернути список, наприклад:


lst = [5, 3, 1, 2, 4]
print(lst)
 
lst.reverse()
print(lst)  # outputs: [4, 2, 1, 3, 5]
 

У Python метод sort() для списків не підтримує параметр reverse=2. Параметр reverse повинен бути булевим значенням (True або False). Якщо ви хочете відсортувати список у зворотному порядку, потрібно передати reverse=True.

Ось правильний спосіб відсортувати список у зворотному порядку:

python
Копіювати код
lst = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
lst.sort(reverse=True)
print(lst)
Цей код відсортує список lst у зворотному порядку, тобто від найбільшого до найменшого значення.

А чому код відпрацював реверсивно?
ChatGPT
Код lst.sort(reverse=2) може здатися, що працює, але це результат того, як Python обробляє параметр reverse у функції sort(). У Python reverse — це булевий параметр, і коли ви передаєте значення 2, Python інтерпретує його як True, оскільки будь-яке ненульове значення в булевому контексті вважається True.

Ось як це працює:

reverse=True: Сортує список у зворотному порядку (від найбільшого до найменшого).
reverse=False (за замовчуванням): Сортує список у звичайному порядку (від найменшого до найбільшого).
В Python, будь-яке ненульове значення, передане параметру reverse, буде інтерпретоване як True. Отже, reverse=2 еквівалентно reverse=True, і тому ваш список буде відсортовано у зворотному порядку.

Приклад для пояснення:

python
Копіювати код
lst = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]

# Сортуємо у зворотному порядку
lst.sort(reverse=2)
print(lst)  # Виведе [9, 6, 5, 5, 5, 4, 3, 3, 2, 1, 1]
Цей результат відповідає очікуваному при reverse=True.
Ваша операція зрезання списку (slicing) в Python працює так:

python
Копіювати код
my_list = [10, 8, 6, 4, 2]
new_list = my_list[1:-1]
print(new_list)
Ось як це працює:

Розбір зрезання:
Індекс 1: Це стартовий індекс. Вибираються елементи починаючи з індексу 1 (другий елемент у списку).

Індекс -1: Це кінцевий індекс (не включений в результат). -1 означає останній елемент списку, тому my_list[1:-1] вибирає всі елементи до останнього, але без включення останнього елемента.

Конкретний приклад:
my_list[1:-1] означає:
Почати з елемента з індексом 1 (тобто 8).
Закінчити перед елементом з індексом -1 (тобто перед 2).
Ось як виглядає my_list:

makefile
Копіювати код
0: 10
1:  8
2:  6
3:  4
4:  2
Отже, my_list[1:-1] вибирає елементи з індексів 1, 2, і 3, тобто [8, 6, 4].

Результат:
python
Копіювати код
new_list = [8, 6, 4]
Так що new_list міститиме [8, 6, 4].

У цьому розділі ви дізнаєтеся, як обробляти списки за допомогою фрагментів і операторів in і not in . Ви також проаналізуєте кілька простих програм, які використовують концепцію списків, щоб навчитися застосовувати їх у більш складних проектах.

3.6.1 Внутрішнє життя списків

Тепер ми хочемо показати вам одну важливу і дуже дивовижну особливість списків, яка сильно відрізняє їх від звичайних змінних.

Ми хочемо, щоб ви запам’ятали його – це може вплинути на ваші майбутні програми та спричинити серйозні проблеми, якщо ви його забудете чи не помітите.

Подивіться на фрагмент у редакторі.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
list_1 = [1]
list_2 = list_1


Консоль 
термінал
синхронізація
Програма:

створює одноелементний список з назвоюсписок_1;
призначає його до нового списку під назвоюсписок_2;
змінює єдиний елементсписок_1;
роздруковуєсписок_2.
Дивним є той факт, що програма виводить:[2], ні[1], що здається очевидним рішенням.

Списки (та багато інших складних сутностей Python) зберігаються інакше, ніж звичайні (скалярні) змінні.

Ви можете сказати, що:

ім'я звичайної змінної - це ім'я її вмісту ;
ім'я списку - це ім'я місця пам'яті, де зберігається список .
Прочитайте ці два рядки ще раз – різниця суттєва для розуміння того, про що ми будемо говорити далі.

Завдання:список_2 = список_1копіює назву масиву, а не його вміст. По суті, дві назви (список_1ісписок_2) визначити те саме місце в пам’яті комп’ютера. Зміна одного з них впливає на інший, і навпаки.

Як ти з цим справляєшся?

3.6.2 Потужні зрізи
На щастя, рішення у вас під рукою – воно називається шматочок .

Фрагмент — це елемент синтаксису Python, який дозволяє створити нову копію списку або його частини .

Він фактично копіює вміст списку, а не назву списку.

Це саме те, що вам потрібно. Подивіться на фрагмент нижче:


list_1 = [1]
list_2 = list_1[:]
list_1[0] = 2
print(list_2)
 
Його вихід є[1].

Ця непомітна частина коду описана як[:]може створити абсолютно новий список.

Одна з найзагальніших форм зрізу виглядає наступним чином:

my_list[start:end]
Як бачите, це нагадує індексування, але двокрапка всередині має велике значення.

Зріз цієї форми створює новий (цільовий) список, беручи елементи з вихідного списку ‒ елементи індексів зпочатокдокінець - 1.

Примітка: нікінецьале щобкінець - 1. Елемент з індексом, рівнимкінецьє першим елементом, який не бере участі в нарізці .

Можливе використання від’ємних значень як для початку, так і для кінця (як і в індексуванні).

Подивіться на фрагмент:


my_list = [10, 8, 6, 4, 2]
new_list = my_list[1:3]
print(new_list)
 
Theновий_списоксписок матимекінець - початок(3 - 1 = 2) елементи ‒ ті, індекси яких дорівнюють1і2(але не3).

Вихід фрагмента:[8, 6]

Запустіть код у редакторі, щоб побачити, як Python копіює весь список і деякі фрагменти списку. Сміливо експериментуйте!

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
3.6.3 Зрізи – негативні індекси
Подивіться на фрагмент нижче:

my_list[start:end]
 
Повторити:

початок– індекс першого елемента, включеного в зріз ;
кінецьє індексом першого елемента, не включеного в зріз.
Ось як негативні індекси працюють із зрізом:


my_list = [10, 8, 6, 4, 2]
new_list = my_list[1:-1]
print(new_list)
 
Вихід фрагмента:

[8, 6, 4]
Вихід
Якщопочатоквизначає елемент, що лежить далі, ніж описанийкінець(з початку списку), фрагмент буде порожнім :


my_list = [10, 8, 6, 4, 2]
new_list = my_list[-1:1]
print(new_list)
 
Вихід фрагмента:

[]
Вихід
Якщо ви опуститепочатоку вашому фрагменті передбачається, що ви хочете отримати фрагмент, який починається з елемента з індексом0.

Іншими словами, зріз цієї форми:

my_list[:end]
 
є більш компактним еквівалентом:

my_list[0:end]
 
Подивіться на фрагмент нижче:


my_list = [10, 8, 6, 4, 2]
new_list = my_list[:3]
print(new_list)
 
Ось чому його вихід:[10, 8, 6].

Аналогічно, якщо ви опуститекінецьу вашому фрагменті передбачається, що ви хочете, щоб фрагмент закінчувався на елементі з індексомlen(my_list).

Іншими словами, зріз цієї форми:

my_list[start:]
 
є більш компактним еквівалентом:

my_list[start:len(my_list)]
 
Подивіться на наступний фрагмент:


my_list = [10, 8, 6, 4, 2]
new_list = my_list[3:]
print(new_list)
 
Таким чином, його вихід:[4, 2].

Як ми вже говорили раніше, пропускаючи обидвапочатокікінецьробить копію всього списку :


my_list = [10, 8, 6, 4, 2]
new_list = my_list[:]
print(new_list)
 
Вихід фрагмента:[10, 8, 6, 4, 2].

Детальніше про інструкцію del
Описане ранішеделінструкція може видаляти більше, ніж просто елементи списку одночасно – вона також може видаляти фрагменти :


my_list = [10, 8, 6, 4, 2]
del my_list[1:3]
print(my_list)
 
Примітка: у цьому випадку зріз не створює жодного нового списку !

Вихід фрагмента:[10, 4, 2].

Також можливе видалення всіх елементів одночасно:


my_list = [10, 8, 6, 4, 2]
del my_list[:]
print(my_list)
 
Список стає порожнім, і виводиться:[].

Видалення фрагмента з коду різко змінює його значення.

Поглянь:


my_list = [10, 8, 6, 4, 2]
del my_list
print(my_list)
 
Theделінструкція видалить сам список, а не його вміст .

Theдрукувати()виклик функції з останнього рядка коду спричинить помилку виконання.

3.6.4 Оператори in та not in
Python пропонує два дуже потужні оператори, які можуть переглядати список, щоб перевірити, чи зберігається певне значення в списку чи ні .

Ці оператори:


elem in my_list
elem not in my_list
 
Перший з них (в) перевіряє, чи даний елемент (його лівий аргумент) на даний момент зберігається десь у списку (правий аргумент) ‒ оператор повертаєправдав цьому випадку.

Другий (не в) перевіряє, чи даний елемент (його лівий аргумент) відсутній у списку – оператор повертаєправдав цьому випадку.

Подивіться на код у редакторі. Фрагмент показує обидва оператори в дії. Чи можете ви вгадати його результат? Запустіть програму, щоб перевірити, чи ви мали рацію.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
3.6.5 Списки – кілька простих програм
Тепер ми хочемо показати вам кілька простих програм, які використовують списки.

Перший з них намагається знайти більше значення в списку. Подивіться на код у редакторі.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Концепція досить проста – ми тимчасово припускаємо, що перший елемент є найбільшим, і перевіряємо гіпотезу з усіма іншими елементами в списку.

Виводить код17(як і очікувалося).

Код може бути переписаний для використання нової формидляпетля:


my_list = [17, 3, 11, 5, 1, 9, 7, 15, 13]
largest = my_list[0]
 
for i in my_list:
    if i > largest:
        largest = i
 
print(largest)
 
Програма вище виконує одне непотрібне порівняння, коли перший елемент порівнюється сам із собою, але це зовсім не проблема.

Виводить код17теж (нічого незвичайного).

Якщо вам потрібно заощадити енергію комп'ютера, ви можете використовувати зріз:


my_list = [17, 3, 11, 5, 1, 9, 7, 15, 13]
largest = my_list[0]
 
for i in my_list[1:]:
    if i > largest:
        largest = i
 
print(largest)
 
Виникає питання: яка з цих двох дій споживає більше ресурсів комп’ютера – лише одне порівняння чи нарізка майже всіх елементів списку?

Тепер давайте знайдемо розташування певного елемента в списку:


my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
to_find = 5
found = False
 
for i in range(len(my_list)):
    found = my_list[i] == to_find
    if found:
        break
 
if found:
    print("Element found at index", i)
else:
    print("absent")
 
Примітка:

цільове значення зберігається взнайтизмінна;
поточний статус пошуку зберігається взнайденозмінна (правда/помилковий)
колизнайденостаєправда,дляцикл вийшов.
Припустімо, що ви вибрали в лотерею такі числа:3,7,11,42,34,49.

Випали такі числа:5,11,9,42,3,49.

Питання: скільки чисел ви влучили?

Ця програма дасть вам відповідь:


drawn = [5, 11, 9, 42, 3, 49]
bets = [3, 7, 11, 42, 34, 49]
hits = 0
 
for number in bets:
    if number in drawn:
        hits += 1
 
print(hits)
 
Примітка:

внамальованийсписок зберігає всі витягнуті числа;
вставкисписок зберігає ваші ставки;
вхітизмінна підраховує ваші звернення.
Результат програми:4.


3.6.4 Оператори in та not in
Python пропонує два дуже потужні оператори, які можуть переглядати список, щоб перевірити, чи зберігається певне значення в списку чи ні .

Ці оператори:


elem in my_list
elem not in my_list
 
Перший з них (в) перевіряє, чи даний елемент (його лівий аргумент) на даний момент зберігається десь у списку (правий аргумент) ‒ оператор повертаєправдав цьому випадку.

Другий (не в) перевіряє, чи даний елемент (його лівий аргумент) відсутній у списку – оператор повертаєправдав цьому випадку.

Подивіться на код у редакторі. Фрагмент показує обидва оператори в дії. Чи можете ви вгадати його результат? Запустіть програму, щоб перевірити, чи ви мали рацію.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
3.6.5 Списки – кілька простих програм
Тепер ми хочемо показати вам кілька простих програм, які використовують списки.

Перший з них намагається знайти більше значення в списку. Подивіться на код у редакторі.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Концепція досить проста – ми тимчасово припускаємо, що перший елемент є найбільшим, і перевіряємо гіпотезу з усіма іншими елементами в списку.

Виводить код17(як і очікувалося).

Код може бути переписаний для використання нової формидляпетля:


my_list = [17, 3, 11, 5, 1, 9, 7, 15, 13]
largest = my_list[0]
 
for i in my_list:
    if i > largest:
        largest = i
 
print(largest)
 
Програма вище виконує одне непотрібне порівняння, коли перший елемент порівнюється сам із собою, але це зовсім не проблема.

Виводить код17теж (нічого незвичайного).

Якщо вам потрібно заощадити енергію комп'ютера, ви можете використовувати зріз:


my_list = [17, 3, 11, 5, 1, 9, 7, 15, 13]
largest = my_list[0]
 
for i in my_list[1:]:
    if i > largest:
        largest = i
 
print(largest)
 
Виникає питання: яка з цих двох дій споживає більше ресурсів комп’ютера – лише одне порівняння чи нарізка майже всіх елементів списку?

Тепер давайте знайдемо розташування певного елемента в списку:


my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
to_find = 5
found = False
 
for i in range(len(my_list)):
    found = my_list[i] == to_find
    if found:
        break
 
if found:
    print("Element found at index", i)
else:
    print("absent")
 
Примітка:

цільове значення зберігається взнайтизмінна;
поточний статус пошуку зберігається взнайденозмінна (правда/помилковий)
колизнайденостаєправда,дляцикл вийшов.
Припустімо, що ви вибрали в лотерею такі числа:3,7,11,42,34,49.

Випали такі числа:5,11,9,42,3,49.

Питання: скільки чисел ви влучили?

Ця програма дасть вам відповідь:


drawn = [5, 11, 9, 42, 3, 49]
bets = [3, 7, 11, 42, 34, 49]
hits = 0
 
for number in bets:
    if number in drawn:
        hits += 1
 
print(hits)
 
Примітка:

внамальованийсписок зберігає всі витягнуті числа;
вставкисписок зберігає ваші ставки;
вхітизмінна підраховує ваші звернення.
Результат програми:4.


3.6.7 РЕЗЮМЕ РОЗДІЛУ
1. Якщо у вас є списоксписок_1, то таке призначення:список_2 = список_1не робить копіюсписок_1список, але створює зміннісписок_1ісписок_2 вказувати на один і той самий список у пам'яті . Наприклад:


vehicles_one = ['car', 'bicycle', 'motor']
print(vehicles_one) # outputs: ['car', 'bicycle', 'motor']
 
vehicles_two = vehicles_one
del vehicles_one[0] # deletes 'car'
print(vehicles_two) # outputs: ['bicycle', 'motor']
 
2. Якщо ви хочете скопіювати список або частину списку, ви можете зробити це, виконавши нарізку :


colors = ['red', 'green', 'orange']
 
copy_whole_colors = colors[:]  # copy the entire list
copy_part_colors = colors[0:2]  # copy part of the list
 
3. Ви також можете використовувати негативні індекси для виконання зрізів. Наприклад:


sample_list = ["A", "B", "C", "D", "E"]
new_list = sample_list[2:-1]
print(new_list)  # outputs: ['C', 'D']
 
4. Theпочатокікінецьпараметри є необов'язковими під час виконання зрізу:список[початок:кінець], наприклад:


my_list = [1, 2, 3, 4, 5]
slice_one = my_list[2: ]
slice_two = my_list[ :2]
slice_three = my_list[-2: ]
 
print(slice_one)  # outputs: [3, 4, 5]
print(slice_two)  # outputs: [1, 2]
print(slice_three)  # outputs: [4, 5]
 
5. Ви можете видалити фрагменти за допомогоюделінструкція:


my_list = [1, 2, 3, 4, 5]
del my_list[0:2]
print(my_list)  # outputs: [3, 4, 5]
 
del my_list[:]
print(my_list)  # deletes the list content, outputs: []
 
6. За допомогою ключових слів можна перевірити, чи існують деякі елементи в списку чи їх немаєвіне в, наприклад:


my_list = ["A", "B", 1, 2]
 
print("A" in my_list)  # outputs: True
print("C" not in my_list)  # outputs: True
print(2 not in my_list)  # outputs: False
 


3.7.1 Lists in lists
3.7.1 Списки в списках

Списки можуть складатися зі скалярів (а саме чисел) і елементів набагато складнішої структури (ви вже бачили такі приклади, як рядки, булеві значення чи навіть інші списки в попередньому розділі Підсумкові уроки). Давайте ближче розглянемо випадок, коли елементи списку є просто списками .

Ми часто зустрічаємо такі масиви в нашому житті. Мабуть, найкращим прикладом цього є шахова дошка .

Шахова дошка складається з рядків і стовпців. Є вісім рядків і вісім стовпців. Кожен стовпець позначено літерами від A до H. Кожен рядок позначено цифрами від одного до восьми.

Розташування кожного поля позначається парами буква-цифра. Таким чином, ми знаємо, що нижній лівий кут дошки (з білою турою) — A1, а протилежний кут — H8.

Припустімо, що ми можемо використовувати вибрані числа для представлення будь-якої шахової фігури. Ми також можемо припустити, що кожен рядок на шахівниці є списком .

Подивіться на код нижче:


row = []
 
for i in range(8):
    row.append(WHITE_PAWN)
 
Він створює список, що містить вісім елементів, що представляють другий рядок шахової дошки – рядок, заповнений пішаками (припустимо, щоБІЛА_ПІШАКАце попередньо визначений символ, що представляє білого пішака).

Розуміння списку
Такого ж ефекту можна досягти за допомогою розуміння списку , спеціального синтаксису, який використовується Python для заповнення масивних списків.

Розуміння списку насправді є списком, але створюється на льоту під час виконання програми та не описується статично .

Подивіться на фрагмент:


row = [WHITE_PAWN for i in range(8)]
 
Частина коду, розміщена в дужках, визначає:

дані, які будуть використані для заповнення списку (БІЛА_ПІШАКА)
речення, яке визначає, скільки разів дані зустрічаються в списку (для i в діапазоні (8))
Подивіться на деякі інші приклади розуміння списку :

Приклад №1:


squares = [x ** 2 for x in range(10)]
 
Фрагмент створює список із десяти елементів, заповнений квадратами з десяти цілих чисел, починаючи з нуля (0, 1, 4, 9, 16, 25, 36, 49, 64, 81)

Приклад №2:


twos = [2 ** i for i in range(8)]
 
Фрагмент створює восьмиелементний масив, що містить перші вісім ступенів двійки (1, 2, 4, 8, 16, 32, 64, 128)

Приклад №3:


odds = [x for x in squares if x % 2 != 0 ]
 
Фрагмент створює список лише з непарними елементамиквадратівсписок.

3.7.2 Двовимірні масиви
Давайте також припустимо, що попередньо визначений символ назПУСТИЙпозначає порожнє поле на шахівниці.

Отже, якщо ми хочемо створити список списків, що представляє всю шахівницю, це можна зробити таким чином:


board = []
 
for i in range(8):
    row = [EMPTY for i in range(8)]
    board.append(row)
 
Примітка:

внутрішня частина петлі створює ряд, що складається з восьми елементів (кожен з них дорівнюєПУСТИЙ) і додає його додошкасписок;
зовнішня частина повторює його вісім разів;
загалом,дошкасписок складається з 64 елементів (всі дорівнюютьПУСТИЙ)
Ця модель ідеально імітує справжню шахову дошку, яка фактично являє собою список із восьми елементів, усі з яких є одними рядками. Підсумуємо наші спостереження:

елементами рядків є поля, по вісім у рядку;
елементами шахової дошки є ряди, по вісім на шахівницю.
Theдошкатепер змінна є двовимірним масивом . Його також називають, за аналогією з алгебраїчними термінами, матрицею .

Оскільки списки можуть бути вкладеними , ми можемо скоротити створення дошки таким чином:


board = [[EMPTY for i in range(8)] for j in range(8)]
 
Внутрішня частина створює рядок, а зовнішня – список рядків.

Для доступу до вибраного поля дошки потрібні два індекси ‒ перший виділяє рядок; другий ‒ номер поля всередині рядка, який де-факто є номером стовпця.

Подивіться на шахову дошку. Кожне поле містить пару індексів, які слід надати для доступу до вмісту поля:


3.7.4 РЕЗЮМЕ РОЗДІЛУ
1. Розуміння списків дозволяє створювати нові списки з існуючих у стислий та елегантний спосіб. Синтаксис розуміння списку виглядає наступним чином:

[expression for element in list if conditional]
 
який насправді є еквівалентом наступного коду:

for element in list:
    if conditional:
        expression
 
Ось приклад розуміння списку – код створює список із п’яти елементів, заповнений першими п’ятьма натуральними числами, зведеними до степеня 3:


cubed = [num ** 3 for num in range(5)]
print(cubed) # outputs: [0, 1, 8, 27, 64]
 

2. Ви можете використовувати вкладені списки в Python для створення матриць (тобто двовимірних списків). Наприклад:
![img_4.png](img_4.png)


# A four-column/four-row table ‒ a two dimensional array (4x4)
 
table = [[":(", ":)", ":(", ":)"],
         [":)", ":(", ":)", ":)"],
         [":(", ":)", ":)", ":("],
         [":)", ":)", ":)", ":("]]
 
print(table)
print(table[0][0])  # outputs: ':('
print(table[0][3])  # outputs: ':)'
 

3. Ви можете вкладати скільки завгодно списків у списки, створюючи таким чином n-вимірні списки, наприклад, три-, чотири- або навіть шістдесятичотири-вимірні масиви. Наприклад:

![img_5.png](img_5.png)

# Cube - a three-dimensional array (3x3x3)
 
cube = [[[':(', 'x', 'x'],
         [':)', 'x', 'x'],
         [':(', 'x', 'x']],
 
        [[':)', 'x', 'x'],
         [':(', 'x', 'x'],
         [':)', 'x', 'x']],
 
        [[':(', 'x', 'x'],
         [':)', 'x', 'x'],
         [':)', 'x', 'x']]]
 
print(cube)
print(cube[0][0][0])  # outputs: ':('
print(cube[2][2][0])  # outputs: ':)'


a = 1
b = 0
c = a & b
d = a | b
e = a ^ b

print(c + d + e)

Відповів 0
Правильно 2 чому
Що є результатом наступного фрагмента?


my_list = [1, 2, 3, 4]
print(my_list[-3:-2])
 
Відповів [2,3] вірно 2. 


Друге завдання:


vals = [0, 1, 2]
vals[0], vals[2] = vals[2], vals[0]
 

Відповів Не змінює
Правильно - перевертає


Скільки елементів міститьмій_списоксписок містить?


my_list = [i for i in range(-1, 2)]
 
відповів 4 правильна відповідь 3
![img_6.png](img_6.png)
Давайте розглянемо кожну задачу окремо, щоб пояснити правильні відповіді.

Завдання 1
python
Копіювати код
a = 1
b = 0
c = a & b
d = a | b
e = a ^ b

print(c + d + e)
Пояснення:

a & b (побітове AND): Результат 1 & 0 дорівнює 0.
a | b (побітове OR): Результат 1 | 0 дорівнює 1.
a ^ b (побітове XOR): Результат 1 ^ 0 дорівнює 1.
Тепер додаємо ці результати:

c + d + e = 0 + 1 + 1 = 2
Тому правильна відповідь – 2.

Завдання 2
python
Копіювати код
my_list = [1, 2, 3, 4]
print(my_list[-3:-2])
Пояснення:

Розглянемо зріз my_list[-3:-2]:

-3 вказує на третій елемент з кінця, тобто 2.
-2 вказує на другий елемент з кінця, тобто 3.
Зріз [start:end] включає елемент start і всі наступні до, але не включаючи end. Тобто, my_list[-3:-2] включає тільки 2.

Тому правильна відповідь – [2].

Завдання 3
python
Копіювати код
vals = [0, 1, 2]
vals[0], vals[2] = vals[2], vals[0]
Пояснення:

Тут ми обмінюємо значеннями елементи vals[0] і vals[2]:

Початковий список: [0, 1, 2]
Після обміну: vals[0] стає 2, а vals[2] стає 0, тобто список перетворюється на [2, 1, 0].
Тому правильна відповідь – перевертає список (між елементами 0 і 2).

Завдання 4
python
Копіювати код
my_list = [i for i in range(-1, 2)]
Пояснення:

Розглянемо генератор списку range(-1, 2):

range(-1, 2) генерує значення від -1 до 1 включно, тобто -1, 0, 1.
Тому список містить три елементи: [-1, 0, 1].

Правильна відповідь – 3.

Підсумок:
Побітові операції (&, |, ^): правильна відповідь – 2.
Зріз списку з негативними індексами: правильна відповідь – [2].
Обмін елементів у списку: правильна відповідь – перевертає (між елементами 0 і 2).
Кількість елементів у списку, створеному за допомогою генератора: правильна відповідь – 3.



4.1. Section 1 – Functions

4.1.1 Навіщо нам потрібні функції?
Ви вже багато разів стикалися з функціями , але погляд на їх переваги, який ми вам дали, був досить одностороннім. Ви лише викликали функції, використовуючи їх як інструменти для полегшення життя та спрощення трудомістких і нудних завдань.

Якщо ви хочете, щоб деякі дані були надруковані на консолі, ви використовуєтедрукувати(). Якщо ви хочете прочитати значення змінної, ви використовуєтевведення(), у поєднанні з будь-якимint()абоfloat().

Ви також використали деякі методи , які насправді є функціями, але оголошені дуже специфічним чином.

Тепер ви навчитеся писати та використовувати власні функції. Ми разом напишемо декілька функцій, від дуже простих до досить складних, які вимагатимуть вашої уваги та уваги.

Часто буває так, що певний фрагмент коду багато разів повторюється у вашій програмі . Він повторюється або буквально, або лише з кількома незначними модифікаціями, що складаються з використання інших змінних у тому самому алгоритмі. Буває і так, що програміст не може втриматися від спрощення своєї роботи і починає клонувати такі фрагменти коду за допомогою буфера обміну та операцій копіювання-вставки.

Це може закінчитися таким же розчаруванням, коли раптом виявиться, що в клонованому коді була помилка. Програмісту доведеться багато працювати, щоб знайти всі місця, які потребують виправлень. Також існує високий ризик того, що виправлення спричинять помилки.

Тепер ми можемо визначити першу умову, яка може допомогти вам вирішити, коли почати писати власні функції: якщо певний фрагмент коду починає з’являтися в кількох місцях, розгляньте можливість ізоляції його у формі функції, викликаної з точки, де раніше був розміщений вихідний код.

Може статися так, що алгоритм, який ви збираєтеся застосувати, настільки складний, що ваш код починає неконтрольовано розростатися, і раптом ви помічаєте, що більше не можете так легко орієнтуватися в ньому.

Ви можете спробувати впоратися з проблемою, багато коментуючи код, але незабаром ви виявите, що це різко погіршує вашу ситуацію – забагато коментарів робить код більшим і його важче читати . Деякі кажуть, що добре написану функцію слід розглядати одним поглядом .

Хороший, уважний розробник ділить код (точніше: проблему) на добре ізольовані частини та кодує кожну з них у формі функції .


Це суттєво спрощує роботу програми, оскільки кожен фрагмент коду можна окремо кодувати та тестувати окремо. Описаний тут процес часто називають декомпозицією .

Тепер ми можемо сформулювати другу умову: якщо частина коду стає настільки великою, що її читання та недооцінка може спричинити проблему, подумайте про розділення її на окремі менші проблеми та реалізуйте кожну з них у формі окремої функції .

Ця декомпозиція триває, поки ви не отримаєте набір коротких функцій, легких для розуміння та тестування.

4.1.2 Розкладання
Часто буває, що проблема настільки масштабна і складна, що її неможливо поставити одному розробнику, і над нею доводиться працювати групі розробників . Проблему необхідно розділити між кількома розробниками таким чином, щоб забезпечити їх ефективну та безперебійну співпрацю.

Здається неймовірним, щоб кілька програмістів писали один і той самий фрагмент коду одночасно, тому робота повинна бути розподілена між усіма членами команди.

Цей вид декомпозиції має іншу мету, ніж описана раніше – це не лише розподіл роботи , але й розподіл відповідальності між багатьма розробниками.

Кожна з них записує чітко визначений і описаний набір функцій, які, об’єднавши в модуль (про це ми розповімо трохи пізніше) дадуть кінцевий продукт.

Це підводить нас безпосередньо до третьої умови: якщо ви збираєтеся розділити роботу між кількома програмістами, розкладіть проблему, щоб продукт міг бути реалізований як набір окремо написаних функцій, зібраних разом у різних модулях .

![img_7.png](img_7.png)
4.1.4 Ваша перша функція
Подивіться на фрагмент у редакторі.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
print("Enter a value: ")


Консоль 
термінал
синхронізація
Це досить просто, але ми хочемо, щоб це був лише приклад перетворення повторюваної частини коду у функцію .

Повідомлення, надіслані на консольдрукувати()функції завжди однакові. Звичайно, в такому коді немає нічого поганого, але спробуйте уявити, що вам доведеться робити, якби ваш бос попросив вас змінити повідомлення, щоб зробити його більш ввічливим, наприклад, почати його фразою"Будь ласка,".

Здається, вам доведеться витратити деякий час на зміну всіх входжень повідомлення (звичайно, ви б використовували буфер обміну, але це не полегшило б вам життя). Очевидно, що ви, ймовірно, припуститеся деяких помилок під час процесу внесення поправок, і ви (і ваш бос) будете трохи розчаровані.

Чи можна відокремити таку повторювану частину коду, назвати її та зробити повторно використаною? Це означало б, що зміна, зроблена один раз в одному місці, буде поширена в усіх місцях, де вона використовується .

Звичайно, такий код має працювати лише тоді, коли його явно запущено.

Так, це можливо. Саме для цього і потрібні функції.

Ви повинні це визначити . Слово визначати тут є значущим.

Ось так виглядає найпростіше визначення функції:

def function_name():
    function_body
 
Він завжди починається з ключового словазах(для визначення )
наступний післязахйде назва функції (правила іменування функцій такі ж, як і для іменування змінних)
після назви функції є місце для пари круглих дужок (тут вони нічого не містять, але це скоро зміниться)
рядок повинен закінчуватися двокрапкою ;
рядок безпосередньо післязахпочинає тіло функції ‒ пару (принаймні одну) обов’язково вкладених інструкцій , які виконуватимуться кожного разу, коли функція викликається; примітка: функція закінчується там, де закінчується вкладення , тому вам потрібно бути обережним.
Ми готові визначити нашу функцію підказок . Ми назвемо цеповідомлення- ось:


def message():
    print("Enter a value: ")
Функція надзвичайно проста, але цілком доступна для використання . Ми назвали йогоповідомлення, але ви можете позначити його на свій смак. Давайте використовувати його.

Тепер наш код містить визначення функції:


def message():
    print("Enter a value: ")
 
print("We start here.")
print("We end here.")
 
Примітка: ми взагалі не використовуємо цю функцію – у коді немає її виклику .

Коли ви запускаєте його, ви бачите такий результат:

We start here.
We end here.
Вихід
Це означає, що Python читає визначення функції та запам’ятовує їх, але не запускає жодну з них без вашого дозволу.

Зараз ми змінили код – ми вставили виклик функції між початковим і кінцевим повідомленнями:


def message():
    print("Enter a value: ")
 
print("We start here.")
message()
print("We end here.")
Результат виглядає інакше:

We start here.
Enter a value:
We end here.
Вихід
Тестуйте код, змінюйте його, експериментуйте з ним.

4.1.5 Як працюють функції
Подивіться на картинку праворуч.

Він намагається показати вам весь процес:

коли ви викликаєте функцію, Python запам'ятовує місце, де це сталося, і переходить до викликаної функції;
потім виконується тіло функції ;
досягнення кінця функції змушує Python повернутися на місце безпосередньо після точки виклику.
![img_8.png](img_8.png)

Є дві, дуже важливі, заковики. Ось перший із них:

Ви не повинні викликати функцію, яка невідома на момент виклику.

Пам’ятайте – Python читає ваш код зверху вниз. Він не заглядає вперед, щоб знайти функцію, яку ви забули розмістити в потрібному місці («праворуч» означає «до виклику».)

Ми вставили помилку в цей код – бачите різницю?


print("We start here.")
message()
print("We end here.")
 
 
def message():
    print("Enter a value: ")
Ми перемістили функцію в кінець коду. Чи може Python знайти його, коли виконання досягає виклику?

Ні, це не так. Повідомлення про помилку звучатиме так:

NameError: name 'message' is not defined
Вихід
Не намагайтеся змусити Python шукати функції, які ви не надали в потрібний час.

Другий підступ звучить трохи простіше:

Ви не повинні мати функцію та змінну з однаковими іменами .

Наступний фрагмент є помилковим:


def message():
    print("Enter a value: ")
 
message = 1
Присвоєння значення повідомленню про назву призводить до того, що Python забуває свою попередню роль. Назва функціїповідомленнястає недоступним.

На щастя, ви можете змішувати свій код із функціями – ви не зобов’язані розміщувати всі свої функції у верхній частині вихідного файлу.

Подивіться на фрагмент:


print("We start here.")
 
 
def message():
    print("Enter a value: ")
 
message()
 
print("We end here.")
Це може виглядати дивно, але це абсолютно правильно і працює як задумано.

Давайте повернемося до нашого первинного прикладу та використаємо функцію для правильної роботи, як тут:


def message():
    print("Enter a value: ")
 
message()
a = int(input())
message()
b = int(input())
message()
c = int(input())
 
Змінити повідомлення підказки тепер легко та зрозуміло – це можна зробити, змінивши код лише в одному місці – у тілі функції.

Відкрийте редактор і спробуйте зробити це самостійно.
4.1.6 РЕЗЮМЕ РОЗДІЛУ
1. Функція — це блок коду, який виконує певне завдання під час виклику (виклику) функції. Ви можете використовувати функції, щоб зробити свій код придатним для багаторазового використання, краще впорядкованим і більш читабельним. Функції можуть мати параметри та значення, що повертаються.

2. У Python є принаймні чотири основні типи функцій:

вбудовані функції , які є невід’ємною частиною Python (наприклад,друкувати()функція). Ви можете побачити повний список вбудованих функцій Python на https://docs.python.org/3/library/functions.html .
ті, які надходять із попередньо встановлених модулів (про них ви дізнаєтеся в курсі Python Essentials 2 )
визначені користувачем функції , які написані користувачами для користувачів ‒ ви можете писати власні функції та вільно використовувати їх у своєму коді,
влямбдафункції (ви дізнаєтесь про них у курсі Python Essentials 2 ).
3. Ви можете визначити власну функцію за допомогоюзахключове слово та такий синтаксис:

def your_function(optional parameters):
    # the body of the function
 
Ви можете визначити функцію, яка не приймає жодних аргументів, наприклад:


def message(): # defining a function
    print("Hello") # body of the function
 
message() # calling the function
 
Ви можете визначити функцію, яка також приймає аргументи, так само як функція з одним параметром нижче:


def hello(name): # defining a function
    print("Hello,", name) # body of the function
 
 
name = input("Enter your name: ")
 
hello(name) # calling the function
 
Ми розповімо вам більше про параметризовані функції в наступному розділі. не хвилюйся


4.2. Розділ 2 – Як функції спілкуються зі своїм середовищем

4.2.1 Параметризовані функції
Повна потужність функції розкривається, коли її можна оснастити інтерфейсом, здатним приймати дані, надані ініціатором. Такі дані можуть змінювати поведінку функції, роблячи її більш гнучкою та адаптованою до мінливих умов.

Параметр насправді є змінною, але є два важливі фактори, які роблять параметри різними та особливими:

параметри існують лише всередині функцій, у яких вони були визначені , і єдине місце, де параметр можна визначити, це пробіл між парою дужок узахзаява;
присвоєння значення параметру виконується під час виклику функції шляхом вказівки відповідного аргументу.
def function(parameter):
    ###
 
Не забувайте:

параметри живуть усередині функцій (це їх природне середовище)
аргументи існують поза функціями та є носіями значень, що передаються відповідним параметрам.
Між цими двома світами існує чітка і однозначна межа.

Давайте збагатимо наведену вище функцію лише одним параметром – ми будемо використовувати його, щоб показати користувачеві номер значення, яке запитує функція.

Ми повинні відновитизахзаява ‒ ось так вона виглядає зараз:

def message(number):
    ###
 
Визначення вказує, що наша функція працює лише з одним параметромномер. Ви можете використовувати її як звичайну змінну, але тільки всередині функції – її більше ніде не видно.

Давайте тепер покращимо тіло функції:


def message(number):
    print("Enter a number:", number)
 
Ми використали параметр. Примітка: ми не присвоїли параметру жодного значення. Це правильно?

Так.

Значення для параметра надійде з середовища функції.

Пам'ятайте: вказівка ​​одного або кількох параметрів у визначенні функції також є обов'язковою, і ви повинні виконати її під час виклику. Ви повинні надати стільки аргументів, скільки визначено параметрів .

Якщо цього не зробити, виникне помилка.

Спробуйте запустити код у редакторі.

play_arrow
синхронізація
завантажити
light_mode
темний_режим
Консоль 
термінал
синхронізація
Ось що ви побачите на консолі:

TypeError: message() missing 1 required positional argument: 'number'
Вихід
Це виглядає краще, напевно:


def message(number):
    print("Enter a number:", number)
 
message(1)
 
Крім того, він краще поводиться. Код видасть такий результат:

Enter a number: 1
Вихід
Ви бачите, як це працює? Значення аргументу, що використовується під час виклику (1) було передано у функцію, встановлюючи початкове значення названого параметраномер.

Ми повинні зробити вас чутливими до однієї важливої ​​обставини.

Це законно та можливо мати змінну з таким же іменем, як і параметр функції .

Фрагмент ілюструє це явище:


def message(number):
    print("Enter a number:", number)
 
number = 1234
message(1)
print(number)
 
Подібна ситуація активує механізм, який називається затіненням :

параметрxзатінює будь-яку змінну з таким же ім'ям, але...
... тільки всередині функції, що визначає параметр.
Названий параметрномерє абсолютно відмінною сутністю від названої змінноїномер.

Це означає, що наведений вище фрагмент дасть такий результат:

Enter a number: 1
1234
Вихід

Функція може мати скільки завгодно параметрів , але чим більше у вас параметрів, тим важче запам’ятати їх ролі та призначення.

Давайте модифікуємо функцію – тепер вона має два параметри :

def message(what, number):
    print("Enter", what, "number", number)
 
Це також означає, що для виклику функції знадобляться два аргументи .

Перший новий параметр призначений для назви потрібного значення.

Ось:


def message(what, number):
    print("Enter", what, "number", number)
 
message("telephone", 11)
message("price", 5)
message("number", "number")
 
Це результат, який ви збираєтеся побачити:

Enter telephone number 11
Enter price number 5
Enter number number number
Вихід
Запустіть код, змініть його, додайте більше параметрів і подивіться, як це вплине на результат.

